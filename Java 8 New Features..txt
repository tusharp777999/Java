Java 8 New Features.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Lambda Expressions
Functional Interfaces
	- Predicate
	- Supplier	
	- Consumer
	- Function

Interfaces changes (default & static methods)
Stream API
Method References
Constructor References
Date & Time API changes
Optional class
SplitIterator
StringJoiner
Collection Framework changes


------------------------------------------------------------------------------------------------------------------------------------------------------------
Lambda Expressions
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> LISP is the first Programming Language which supported for Lambda Expression.

LISP
C
C++
C#
Scala
Ruby
Python etc...

-> Java started support for Lambda Expression from 1.8 version (Java is late in Lambdas)
-> Java is an Object Oriented Programming Language. Introducing Lambdas in Java it is supporting Functional Programming also.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Object Oriented Programming Vs Functional Programming?
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In Object Oriented Programming Languages Classes & Objects are main entities.
-> If we want to create a Function in OOP's Languages, that Function should be created inside the class.

-> In Functional Programming, Function can exist outside the scope of an object
-> We can assign Function to a Reference Variable.
-> One Function can be passed as a Parameter to another Function.

------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Lambda?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> A Lambda Expression is just an Anonymous Function
	- No Name.
	- No Modifier.
	- No Return Type.
	- And we use "->" this symbol to represent Lambda.
-> Lambda Expressions are used to implement Functional Programming in Java.
-> By using Lambda Expressions we can write more Readable and Concise code.


Normal Method:

	public void m1() {
		System.out.println("Hi");
	}

Equivalent Lambda:

	() -> System.out.println("Hi");

------------------------------------------------------------------------------------------------------------------------------------------------------------
Why to use Lambda Expressions?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> To write Functional Programming in Java.
-> To write more Readable, Maintainable and Concise code.

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to write Lambda Expressions in Java?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Writing Lambdas is very easy if you know how to write methods in Java.
-> Let us take one example to understand how to write Lambda.

Example 1:
----------

Normal Method:

	public void greet() {
		System.out.println("Hi");
	}

Equivalent Lambda:

	() -> System.out.println("Hi");


Example 2:
----------

Normal Method:

	public void add(int a, int b) {
		System.out.println(a+b);
	}

Equivalent Lambda:

	(a, b) -> System.out.println(a+b);


Example 3:
----------

Normal Method:

	public User getUserById(Integer userId) {
		User user = dao.findById(userId);
		return user;
	}

Equivalent Lambda:

	(userId) -> {
		User user = dao.findById(userId);
		return user;
	};

Example 4:
----------

Normal Method:

public class EmailUtils {

	public Boolean sendMail(String sub, String body, String to){
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setSubject(sub);
		msg.setBody(body);
		msg.setTo(to);

		JavaMailSender sender = new JavaMailSender();
		sender.send(msg);
		return true;
	}

}

Equivalent Lambda:

	(sub, body, to) -> {
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setSubject(sub);
		msg.setBody(body);
		msg.setTo(to);

		JavaMailSender sender = new JavaMailSender();
		sender.send(msg);
		return true;
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to call Lambdas?
------------------------------------------------------------------------------------------------------------------------------------------------------------

Normal Method:
	class Demo {
		public void m1() {
			System.out.println("Hi");
		}
	}

	Demo demo = new Demo();
	demo.m1();

Lambda Way:
	
	class Test {
		() -> System.out.println("Hi");
	}	

-> To call the Normal method of a class we can use the object of that class but to call the Lambda there is no such way of object so for that the concept of Functional Interface is there.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Functional Interface:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> The interface which contains only one abstract method then it is called as Functional interface.
	
	public interface Greeting {
		void greet();
	}	

-> Using Functional Interface we can call or invoke Lambda Expression.
-> Functional Interface can contain any number of Default and Static methods.
-> Functional Interface rule is applicable only for Abstract method. It should contain only one Abstract method and it can contain any number of Static and Default methods.
-> To represent our Interface as Functional Interface we will use @FunctionalInterface annotation.
-> Writing @FunctionalInterface annotation is optional. If we write this annotation compiler will check do we have only one abstract method in the interface or not.

Example 1:(Valid Functional Interface)
--------------------------------------

	@FunctionalInterface
	public interface MyInterface {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

For a proof:

	public interface Demo {
		void m1();
	}

> javac Demo.java
> javap Demo

public interface Demo {
	public abstract void m1();// Here "public abstract" keywords are added by default by the compiler to the method.

}

Example 2:(Invalid Functional Interface)
----------------------------------------

	@FunctionalInterface
	public interface MyInterface {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
		public abstract void m2();
	}

//Here we have 2 abstract methods so that's why it is invalid.

Example 3:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		
	}

-> In the above scenario, Child interface doesn't have any abstract methods. Child having access for the Parent class abstract method hence Child is also Functional Interface.

Example 4:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface overriding Parent interface abstract method hence Child is having only one abstract method. So it is valid Functional Interface.

Example 5:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		void m2();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface having 2 abstract methods hence it is not Functional Interface.

Example 6:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	public interface Child extends Parent {
		void m2();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface can contains any number of abstract methods because it is not having @FunctionalInterface annotation.

Example 7:
----------

	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Parent is Functional Interface only.
-> Writing @FunctionalInterface is optional.
-> If we write @FunctionalInterface, java compiler will verify that is valid Functional Interface or not.

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to invoke Lambdas using Functional Interface?
------------------------------------------------------------------------------------------------------------------------------------------------------------

Without using Lambdas:
----------------------

	public interface MyInterface {
		void m1();
	}

	public class MyApp implements MyInterface {
		public void m1() {
			System.out.println("Hello");
		}

		public static void main(String... args) {
			MyInterface mi = new MyApp();
			mi.m1();
		}
	}

With using Lambdas:
-------------------

	public interface MyInterface {
		void m1();
	}

	public class MyApp {
		public static void main(String... args) {
			MyInterface mi = () -> System.out.println("Hello");
			mi.m1();
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 1: With older approach using implementation classes.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class EnglishGreeting implements Greeting {

	@Override
	public void greet() {
		System.out.println("Hello, Good Morning..!!");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class HindiGreeting implements Greeting {

	@Override
	public void greet() {
		System.out.println("Namaskar...");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisher {

	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		Greeting hindiGreeting = new HindiGreeting();
		wish(hindiGreeting);
		
		Greeting englishGreeting = new EnglishGreeting();
		wish(englishGreeting);
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In above approach we are creating separate implementation class for every language. If we want to support 20 languages then we have to create 20 implementation classes. It is not recommended.
-> To avoid this problem we can use Anonymous implementation class.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2: With older approach using Anonymous implementation for interface.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherAnonymous {
	
	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		wish(new Greeting() {
			@Override
			public void greet() {
				System.out.println("Namaskar...");
			}
		});
		
		wish(new Greeting() {
			@Override
			public void greet() {
				System.out.println("Hello, Good Morning..!!");
			}
		});
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 3: With newer approach using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherLambda {

	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		wish(() -> System.out.println("Namaskar..."));
		
		wish(() -> System.out.println("Hello, Good Morning..!!"));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 4: With newer approach using Lambda(Simplified way).
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherSimplified {

	public static void main(String[] args) {
		Greeting hindiGreeting = () -> System.out.println("Namaskar...");
		hindiGreeting.greet();
		
		Greeting englishGreeting = () -> System.out.println("Hello, Good Morning..!!");
		englishGreeting.greet();
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> In java we have several functional interfaces, they are
	- Runnable
	- Callable
	- ActionListener

------------------------------------------------------------------------------------------------------------------------------------------------------------
Working with Runnable interface available in java.lang package.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Runnable interface contains only one abstract method hence it is called as Functional interface.
	- public void run();

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 1: Using implementation class.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo1 implements Runnable {
	@Override
	public void run() {
		for(int i = 1; i <= 10; i++) {
			System.out.println(i);
		}
	}
	
	public static void main(String[] args) {
		Demo1 demo = new Demo1();
		Thread t = new Thread(demo);
		t.start();
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2: Using Anonymous class implementation.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo2 {
	public static void main(String[] args) {
		Thread t = new Thread(new Runnable() {
			@Override
			public void run() {
				for(int i = 1; i <= 10; i++) {
					System.out.println(i);
				}
			}
		});
		t.start();
	}
}

	or

package com.tushar.beans;

public class Demo3 {
	public static void main(String[] args) {
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				for(int i = 1; i <= 10; i++) {
					System.out.println(i);
				}
			}
		};
		Thread t = new Thread(runnable);
		t.start();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 3: Using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo4 {
	public static void main(String[] args) {
		Runnable runnable = () -> {
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
		};
		
		Thread thread = new Thread(runnable);
		thread.start();
	}
}


	or

package com.tushar.beans;

public class Demo5 {
	public static void main(String[] args) {
		Thread thread = new Thread(() -> {
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
		});
		thread.start();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> In java, We are having Callable interface to work with Multi-Threading.
-> Callable interface contains only one abstract method hence it is called as Functional interface.
	- public Object call();
-> call() returns future object.
-> To execute Callable we will use ExecutorService.
-> ExecutorService is a framework which introduced in java 1.5 version to work with Multi-Threading.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable Examples 1: Using Anonymous class.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		Callable callable = new Callable() {
			@Override
			public Object call() throws Exception {
				for(int i = 1; i <= 20; i++) {
					System.out.println(i);
				}
				return null;
			}
		};
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(callable);
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable Examples 2: Using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		Callable callable = () -> {
			for(int i = 0; i <= 10; i++) {
				System.out.println(i);
			}
			return null;
		};
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(callable);
	}
}

	or

package com.tushar.beans;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(() -> {
			for(int i = 0; i <= 10; i++) {
				System.out.println(i);
			}
			return null;
		});
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Comparator is a predefined interface available in java which is used to implement for Customized sorting.
-> It is present in java.util.Comparator interface contains compare() method.
	- public Interger compare(Object o1, Object o2);

-> We can work with Comparator interface in below 3 ways.
	- Create class to implement Comparator interface and override compare() method.
	- Provide Anonymous implementation for Comparator interface.
	- Provide implementation for Comparator using Lambda Expression.

-> In order to perform Customized sorting we will use Collections.sort() method like below.
	- Collections.sort(listOfObjectsToSort, Comparator<T>);

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 1: Using Normal Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class SortingDemo1 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, new ElementsSortingComparator());
		System.out.println("Elements After Sorting :: " + al);
	}

}

class ElementsSortingComparator implements Comparator<Integer> {
	@Override
	public int compare(Integer o1, Integer o2) {
//		if(o1 > o2) {
//			return -1;
//		} else if(o1 < o2) {
//			return 1;
//		} else {
//			return 0;
//		}
		
		return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 2: Using Anonymous class Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class SortingDemo2 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
			}
		});
		System.out.println("Elements After Sorting :: " + al);
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 3: Using Lambda Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;

public class SortingDemo2 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, (Integer o1, Integer o2) -> {
				return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
			});
		System.out.println("Elements After Sorting :: " + al);
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 1: Using Normal Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class Person {
	private Integer personId;
	private String personName;
	private String personEmail;
	
	public Person() {
		super();
	}

	public Person(Integer personId, String personName, String personEmail) {
		super();
		this.personId = personId;
		this.personName = personName;
		this.personEmail = personEmail;
	}

	public Integer getPersonId() {
		return personId;
	}

	public void setPersonId(Integer personId) {
		this.personId = personId;
	}

	public String getPersonName() {
		return personName;
	}

	public void setPersonName(String personName) {
		this.personName = personName;
	}

	public String getPersonEmail() {
		return personEmail;
	}

	public void setPersonEmail(String personEmail) {
		this.personEmail = personEmail;
	}

	@Override
	public String toString() {
		return "Person [personId=" + personId + ", personName=" + personName + ", personEmail=" + personEmail + "]";
	}
	
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ObjectSorting1 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, new PersonComparator());
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

class PersonComparator implements Comparator<Person> {
	@Override
	public int compare(Person o1, Person o2) {
		return o1.getPersonName().compareTo(o2.getPersonName());
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 2: Using Anonymous class Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ObjectSorting2 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, new Comparator<Person>() {
			@Override
			public int compare(Person o1, Person o2) {
				return o1.getPersonName().compareTo(o2.getPersonName());
			}
		});
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 3: Using Lambda Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ObjectSorting3 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, (o1, o2) -> {
			return o1.getPersonName().compareTo(o2.getPersonName());
		});
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment: Write a java program to sort below Map based on values available in the Map using Lambda Expression.
------------------------------------------------------------------------------------------------------------------------------------------------------------
1   USA
91  India
61  Australia
86  China
33  France
92  Pakistan
852 Hong Kong

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predefined Functional interfaces introduced in java 8.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate
-> Supplier
-> Consumer
-> Function

-> The above Functional interface are provided in java.util.function package.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predicate:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate is pre-defined Functional interface.
-> Predicate is having an abstract method called test() which is used to invoke Lambda Expression.
-> Predicate contains and(), or() & negate() methods which are default methods.
-> Predicate contains isEqual() & not() method which is static method.
-> Predicate is used to perform some conditional check and returns true or false.
-> Predicate is present in java.util.function package.
-> If we have a Lambda which checks condition and returns true or false then we can invoke that Lambda using Predicate Functional interface.

Example:
	- Check whether given number is greater than 20 or not.
	
	//Logic without Lambda
	public boolean test(int number) {
		if(number > 20) {
			return true;
		} else {
			return false;
		}
	}
------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Logic with Lambda
	(number) -> number > 20;
------------------------------------------------------------------------------------------------------------------------------------------------------------
	//With Predicate
	package com.tushar.beans;

	import java.util.function.Predicate;

	public class NumberCheck {
		public static void main(String[] args) {
			Predicate<Integer> predicate = (number) -> number > 20;
			System.out.println(predicate.test(21));
			System.out.println(predicate.test(15));
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to check person name is having 7 characters or not. If name is having 7 or more characters return true otherwise return false.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.function.Predicate;

public class NameLengthCheck {
	public static void main(String[] args) {
		Predicate<String> predicate = name -> name.length() >=7; 
		System.out.println(predicate.test("Tushar Patil"));// true
		System.out.println(predicate.test("Hello"));// false
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to print names which are starting with character 'A' using lambda from below list.
Names: Kajal, Samantha, Anushka, Trisha, Anupama, Nayanthara, Aishwarya.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.function.Predicate;

public class NamesPrinting {
	public static void main(String[] args) {
		String[] names = {"Kajal", "Samantha", "Anushka", "Trisha", "Anupama", "Nayanthara", "Aishwarya"};
		Predicate<String> predicate = name -> name.startsWith("A");
		
		for(String name : names) {
			if(predicate.test(name)) {
				System.out.println(name);
			}
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment:
-----------

Requirement: Write a program to print persons names who are eligible for vote from below person list.

Person Details:
---------------
Name = Raju, Age = 20
Name = Nick, Age = 10
Name = Rani, Age = 21
Name = Sita, Age = 19
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PersonNamesPrinter {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 16);
		Person p4 = new Person("Gita", 24);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> predicate = person -> person.getAge() >= 18;
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person.getName());
			}
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predicate Joining:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> To combine multiple predicates we will use Predicate Joining.
-> We can do method chaining also.
-> We have below methods in Predicate.
	- test() 
		-> It is abstract method.
		-> It takes only one parameter and returns Boolean value.
	- negate() 
		-> It is default method.
		-> It does not take any parameter it just reversed the given predicate.
	- and() 
		-> It is default method.
		-> It combines the predicate and all predicate are true then it return true.
		-> We can do method chaining.
			- Like predicate1.and(predicate2).and(predicateN).
	- or() 
		-> It is default method.
		-> It combines the predicate and any of the predicate is true then returns true.
		-> We can do method chaining.
			- Like predicate1.or(predicate2).or(predicateN).
	- isEqual() 
		-> It is static method. //Not covered in this class
	- not() 
		-> It is static method and now it is deprecated.//Not covered in this class

-> and(), or() & negate() are default methods in Predicate interface.
-> isEqual() & not() are the static methods in Predicate interface.
-> Using and() & or() methods we can achieve predicate joining.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to identify who is eligible for marriage.
Condition: Person age should be >= 21 and <= 64.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 1: and()
----------------

public class PredicateJoinForAnd {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 67);
		Person p4 = new Person("Gita", 14);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> ageLowerUpperLimit = person -> person.getAge() >= 21 && person.getAge() <= 64;
		
		// Here it we are using the conditional operator within single Predicate.
		System.out.println("Predicate with single condition:");
				
		for(Person person : persons) {
			if(ageLowerUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		
		Predicate<Person> ageLowerLimit = person -> person.getAge() >= 21;
		
		Predicate<Person> ageUpperLimit = person -> person.getAge() <= 64;
		
		// Here it we are using the conditional operator which shows a lengthy approach.
		System.out.println("Predicate without joining methods:");
		
		for(Person person : persons) {
			if(ageLowerLimit.test(person) && ageUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		// Here we are using the Predicate joining.
		Predicate<Person> predicate = ageLowerLimit.and(ageUpperLimit);
		System.out.println("Predicate with joining mehtods:");
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person);
			}
		}		
	}
}

Example 2: or()
---------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateJoinForOr {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 67);
		Person p4 = new Person("Gita", 14);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> ageLowerUpperLimit = person -> person.getAge() >= 21 || person.getAge() <= 64;
		
		// Here it we are using the conditional operator within single Predicate.
		System.out.println("Predicate with single condition:");
				
		for(Person person : persons) {
			if(ageLowerUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		
		Predicate<Person> ageLowerLimit = person -> person.getAge() >= 21;
		
		Predicate<Person> ageUpperLimit = person -> person.getAge() <= 64;
		
		// Here it we are using the conditional operator which shows a lengthy approach.
		System.out.println("Predicate without joining methods:");
		
		for(Person person : persons) {
			if(ageLowerLimit.test(person) || ageUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		// Here we are using the Predicate joining.
		Predicate<Person> predicate = ageLowerLimit.or(ageUpperLimit);
		System.out.println("Predicate with joining mehtods:");
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person);
			}
		}		
	}
}

Example 3: negate()
-------------------

package com.tushar.beans;

import java.util.function.Predicate;

public class PredicateEvenCheck {
	public static void main(String[] args) {
		Predicate<Integer> predicate = i -> i % 2 == 0;
		isEvenCheck(predicate, 10);
		isEvenCheckNegate(predicate, 10);
	}
	
	public static void isEvenCheck(Predicate<Integer> predicate, Integer number) {
		System.out.print("Predicate without negate(): ");
		System.out.println(predicate.test(number));
	}
	
	public static void isEvenCheckNegate(Predicate<Integer> predicate, Integer number) {
		System.out.print("Predicate with negate(): ");
		System.out.println(predicate.negate().test(number));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiPredicate:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate<T> takes only one parameter and returns result.
-> If we want to provide 2 parameters as an input for Lambda and return the result then we can use BiPredicate for this.
-> BiPredicate<T, T> is Functional interface which contains a abstract method test().
-> BiPredicate<T, T> takes 2 parameters and returns Boolean value.
-> BiPredicate contains only default methods.
-> Default methods:
	- and()
	- or()
	- negate()
-> BiPredicate does not contains any static method as Predicate have.

Example 1: BiPredicate

package com.tushar.beans;

import java.util.function.BiPredicate;

public class Demo1 {
	public static void main(String[] args) {
		BiPredicate<Integer, Integer> biPredicate = (number1, number2) -> ((number1 + number2) >= 100);
		System.out.println(biPredicate.test(10, 200));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Supplier:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> It is pre-defined Functional interface.
-> It contains only one abstract method i.e. get();
-> It does not contain any default and static methods.
-> Supplier is an interface that does not take any arguments but it produces a value when the get() function got called.
-> Supplier are useful when our Lambda is not taking any input but it is providing some output.
-> There is no BiSupplier because the Supplier don't take any input so no chance of BiSupplier.

Example 1: Get Date
-------------------

package com.tushar.beans;

import java.util.Date;
import java.util.function.Supplier;

public class DateApp {
	public static void main(String[] args) {
		Supplier<Date> dateSupplier = () -> new Date();
		System.out.println(dateSupplier.get());
	}
}

Example 2: Get OTP
------------------

package com.tushar.beans;

import java.util.function.Supplier;

public class OtpGenerator {
	public static void main(String[] args) {
		Supplier<String> otpSupplier = () -> {
			String otp = "";
			for(int i = 1; i <= 6; i++) {
				otp = otp + (int)(Math.random() * 10);
			}
			return otp;
		};
		System.out.println(otpSupplier.get());
		System.out.println(otpSupplier.get());
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Consumer:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> It is pre-defined Functional interface.
-> It contains only one abstract method i.e. accept(T t).
-> It contains only one default method andThen().//Not covered in the class
-> There is no static method in it.
-> Consumer will take only one input but it will not return anything.
-> Consumer can be used in a scenario where our Lambda should take input and perform operation based on the input but no need to return anything.
	- Syntax:
		interface Consumer {
			void accept(T t);
		}

Example 1: Print String and Integer
-----------------------------------

package com.tushar.beans;

import java.util.function.Consumer;

public class ConsumerDemo {
	public static void main(String[] args) {
		Consumer<String> consumer1 = (name) -> System.out.println("Good Morning!!!");
		consumer1.accept("Tushar Patil");
		
		Consumer<Integer> consumer2 = i -> System.out.println(i * i);
		consumer2.accept(10);
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiConsumer:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> If we want to supply 2 inputs for a Lambda and no return then we can use BiConsumer.
	- Syntax:
		interface BiConsumer<T, U> {
			void accept(T t, U u);
		}
		
		T - Represents first argument.
		U - Represents second argument.
-> It contains only one default method andThen().//Not covered in the class
-> There is no static method in it.
Note: BiConsumer interface having only one abstract method i.e. accept(T t, U u). It will take 2 inputs and performs operation but it will not return 
anything.

Example 1: Print Strings
------------------------

package com.tushar.beans;

import java.util.function.BiConsumer;

public class BiConsumerDemo {
	public static void main(String[] args) {
		BiConsumer<String, String> biConsumer = (string1, string2) -> {
			System.out.println("Hi, I am " + string1);
			System.out.println("I am from " + string2);
		};
		
		biConsumer.accept("Tushar", "Pune");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Function:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Function is pre-defined Functional interface.
-> Function is having an abstract method called apply() which is used to invoke Lambda Expression.
-> apply() method takes 1 input and returns output.
-> Function contains compose() & andThen() methods which are default methods.
-> Function contains identity() method which is static method.
-> Function is used to take input and provide output.
-> Function is present in java.util.function package.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a Lambda for below method and call using pre-defined Functional interface.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 1:
----------

public Ticket bookTicket(Passenger passenger) {
	//Logic to book ticket
	return ticketObject;
}

-> As we can see, above bookTicket() method taking passenger object as input and returning Ticket object as output.
-> To work with this kind of requirements we can use Function interface.
-> Function is a pre-defined Functional interface 
-> Function interface can take input and provide output.
-> Function interface contains only one abstract method i.e. R apply(T t)
	- Syntax:
		interface Function {
			R apply(T t);
		}
		
		T - Represents input/parameter object type.
		R - Represents returning object type.

Note: In realtime most of our requirements will match with Function interface only.

Example 2:
----------

Taking LoginForm object as input and returning String as output.

public String login(LoginForm input) {
	//Check login credentials with DB.
	return status;
}

Example 3:
----------

Taking UserForm object input and returning String as output.

public String registerUser(UserForm input) {
	//Insert user in DB.
	return status;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.function.Function;

public class FunctionDemo1 {
	public static void main(String[] args) {
		Function<String, String> function1 = string -> string.toUpperCase();
		System.out.println(function1.apply("Tushar"));
		
		Function<Integer, Integer> function2 = number -> number * number;
		System.out.println(function2.apply(10));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiFunction:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> BiFunction is pre-defined Functional interface.
-> BiFunction is having an abstract method called apply() which is used to invoke Lambda Expression.
-> apply() method takes 2 inputs and returns output.
-> BiFunction contains andThen() method which is default method.
-> BiFunction does not contain any static method.
-> BiFunction is used to take input and provide output.
-> BiFunction is present in java.util.function package.

	- Syntax:
		interface BiFunction<T, U, R> {
			R apply(T t, U u);
		}

		T - First argument type.
		U - Second argument type.
		R - Third argument type.

Example 1:
----------

package com.tushar.beans;

import java.util.function.BiFunction;

public class BiFunctionDemo1 {
	public static void main(String[] args) {
		BiFunction<Integer, Integer, Integer> biFunction1 = (number1, number2) -> (number1 * number2);
		System.out.println(biFunction1.apply(10, 20));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Summary:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate interface will take one input and returns Boolean value as an output.
	- test(argument 1) 
		-> abstract method.
	- and() 
		-> default method.
	- or() 
		-> default method.
	- negate() 
		-> default method.
	- isEqual()
		-> static method.
	- not()
		-> static method.

-> BiPredicate interface will take 2 inputs and returns Boolean value as an output.
	- test(argument 1, argument 2) 
		-> abstract method.
	- and() 
		-> default method.
	- or() 
		-> default method.
	- negate() 
		-> default method.
Note: Don't have any static method as Predicate have.

-> Supplier interface will not take any input and returns output.
	- get() 
		-> abstract method.
Note 1: Supplier don't have default and static methods.
Note 2: Supplier don't have BiSupplier because it doesn't take any input. 

-> Consumer interface will take one input and it won't return anything.
	- accept(argument 1)
		-> abstract method.
	- andThen() 
		-> default method.
Note: Don't have any static method.

-> BiConsumer interface will take 2 inputs and it won't return anything.
	- accept(argument 1, argument 2)
		-> abstract method.
	- andThen() 
		-> default method.
Note: Don't have any static method.

-> Function interface will take one input and returns output.
	- returnType apply(argument 1)
		-> abstract method.
	- andThen() 
		-> default method.
	- compose() 
		-> default method.
	- identity()
		-> static method.

-> BiFunction interface will take 2 inputs and returns output.
	- returnType apply(argument 1, argument 2)
		-> abstract method.
	- andThen() 
		-> default method.
Note: Don't have any static method.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Interface related changes in Java 8:
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> What is interface?
	- Interface is a contract which contains specification.
	- Interface should contain only abstract methods. (This is true upto Java 1.7v)
	- The method which does not having body is called as abstract method.
		-> Example: 
			public User getUserById(Integer userId);
	- From Java 1.8v onwards we can write concrete methods also in interface.
	- The method which contains body is called as Concrete method.
	- Example:
		public Integer sum(Integer number1, Integer number2) {
			return a + b;
		}
Note: Interface concrete methods should be "default", "static" or "private(Java 9)".

-> abstract methods available in the interface are by default public and abstract. No need to write public and abstract keyword explicitly.
	- Example: public abstract void cleanVehicle(); => void cleanVehicle();

Example 1:
----------

package com.tushar.beans;

public interface Vehicle {
	void cleanVehicle();//By default it having public abstract keyword. It is abstract method.

	default void startVehicle() {// Default method with default keyword which is concrete method and valid in interface.
		System.out.println("Vehicle started!!!");
	}
}

-> As per Java rule, when we are implementing interface, we have to implement all the abstract methods available in the interface.
-> If we want to add any new abstract method in interface then the implemented classes will be affected. (Both Santro and I20Car).
-> To avoid this problem default method got introduced in Java 1.8v.
-> If we want to add new functionality in Vehicle interface that should be applicable for only I20Car not for Santro. Without affecting the existing 
functionality then we should go for "default" method concept. And if we want to allow the overriding the go for default method. Need to call using 
implementation class object.
-> If there is some logic which is common across the implementation class without affecting the existing functionality and don't want to allow overriding the 
we should go for static method. Need to call using Interface name.

Example:
--------

package com.tushar.beans;

public interface Vehicle {
	void cleanVehicle();//By default it having public abstract keyword. It is abstract method.
	
	default void sensor() {
		System.out.println("Sensor added!!!");
	}
	
	default void startVehicle() {// Default method with default keyword which is concrete method and valid in interface.
		System.out.println("Vehicle started!!!");
	}
	
	static void fuelCheck() {
		System.out.println("Checking fuel!!!");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class I20Car implements Vehicle {
	@Override
	public void cleanVehicle() {
		System.out.println("I20 car is getting cleaned.");
	}
	
	@Override
	public void sensor() {
		System.out.println("Sensor overrided in I20 class!!!");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class Santro implements Vehicle {
	@Override
	public void cleanVehicle() {
		System.out.println("Santro car is getting cleaned.");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class MyApp {
	public static void main(String[] args) {
		Vehicle santroVehicle = new Santro();
		santroVehicle.cleanVehicle();
		santroVehicle.startVehicle();
		
		Vehicle i20Vehicle = new I20Car();
		i20Vehicle.cleanVehicle();//It is abstract method which is implemented in the implementation classes and and called using implementation 
					class object.
		i20Vehicle.startVehicle();//Default method call which is not overridden in I20Car and called using implementation class object.
		i20Vehicle.sensor();//Default method call which is overridden in I20Car class and called using implementation class object.
		Vehicle.fuelCheck();//Static method call
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

Static Method:
--------------
-> We can add static method in interface.
-> This concept introduced in Java 1.8v.
-> For static method static keyword is mandatory.
-> The reason to introduced this concept is that existing functionality (implemented classes) should not get disturbed and also should not implement 
forcefully to override this newly added method.
-> To call this static method we need interface name.
-> If our need is that a concrete method which cannot be able to override in the implementation classes then go for static method concept.


Default Method:
---------------
-> We can add default method in interface.
-> This concept introduced in Java 1.8v.
-> For default method "default" keyword is mandatory.
-> The reason to introduced this concept is that existing functionality (implemented classes) should not get disturbed and also should not implement 
forcefully to override this newly added method.
-> To call this default method we need implemented class object.
-> If our need is that a concrete method which can be override in the implementation classes then go for default method concept

Private Method://Not covered in the class.
---------------



------------------------------------------------------------------------------------------------------------------------------------------------------------
Method Reference:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Method references, as the name suggests this is used to refer from one method to another method.
-> Method references are similar to object references.

-> Consumer is a Functional interface which will take input and will perform operation on that input but it will not return anything, Consumer contains 
accept() method.

Example 1:
----------
	Cosumer<String> consumer = s -> System.out.println(s);
	consumer.accept("Hi");

-> The above code can be written like below using static Method reference.
	Cosumer<String> consumer = s -> System.out::println;
	consumer.accept("Hi");

-> Function is a Functional interface which will take the input and will return output. Function contains apply() method.

Example 2:
----------
	Function<Person, Integer> function = p -> p.getAge();
	Integer personage = function.apply(personObject);

-> The above code can be written like below using instance Method reference.
	Function<Person, Integer> function = p -> p::getAge();
	Integer personage = function.apply(personObject);

Example 3:
----------
package com.tushar.beans;

import java.util.function.Consumer;

public class MethodReference1 {
	public static void main(String[] args) {
		Consumer<String> consumer = c -> System.out.println(c);
		consumer.accept("Hello");
		
		Consumer<String> consumerMethodReference = System.out::println;
		consumer.accept("Hello Reference");
	}
}

Example 4:
----------
package com.tushar.beans;

public class Test {
	
	public static void m2() {
		System.out.println("This is m2() method...");
	}
	
	public static void main(String[] args) {
		MyInterface myInterface = () -> System.out.println("This is m1() method...");
		myInterface.m1();
		
		MyInterface myInterface1 = Test::m2;
		myInterface1.m1();
	}
}

interface MyInterface {
	void m1();
}

When you go for Method Reference?
---------------------------------
-> When you want to implement a Functional interface without writing a Lambda and you want to reuse the existing method in place of Lambda then we go for 
Method reference.

-> By using Method reference we can reuse existing logic instead of writing Lambdas.
-> Method reference is alternative to Lambda.

	 
------------------------------------------------------------------------------------------------------------------------------------------------------------
Constructor Reference:
------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 1:
----------

package com.tushar.beans;

public class Sample {
	public static void main(String[] args) {
		SampleInterface sampleInterface = () -> new Sample();
		SampleInterface sampleInterface1 = Sample::new;
	}
}

interface SampleInterface {
	Sample get();
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Stream API:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> The addition of the Stream API was one of the major feature added to the Java 8.
-> A Stream in Java is defined as Sequence of elements from source that supports aggregate operations.
-> Stream API is used to process the data.
-> Stream API is not storing the data, It is meant for processing the data.

Note: In java we will use Collections to store the data and Streams to process the data.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Few important points about Stream:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Stream is not a data structure.
-> Stream is used to perform bunch of operations on the data.
-> Stream will take the data from a Collection or Array.
-> Stream will perform operations on the data of Collection or Array but it will not change original Collection or Array data.

Scenario 1:  Search flights from HYD to CJB
-------------------------------------------

	Condition 1: Non-stop flight.

	Condition 2: Indigo Airlines.

	Condition 3: Before 12 p.m.

	Condition 4: Budget 5000 INR (Economy).

-> In the above requirement, we have several conditions to filter the data.
-> Filtering the data is nothing but, performing some operations on the original data.

Scenario 2: Get the TCS Employee details
----------------------------------------
	
	Condition 1: Get the Employees who are working in Hyderabad location.

	Condition 2: Salary >= 2.5 Lakh.

	Condition 3: Who are working in TCS from 2015.

	Condition 4: Who are working in passport project.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Stream Creation:
------------------------------------------------------------------------------------------------------------------------------------------------------------
1. From Collections (List, Set, etc.)
	You can create a stream from any collection (such as a List, Set, or Queue) by calling the stream() method on the collection.

Example:
--------
	List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
	Stream<Integer> stream = list.stream();  // Create a stream from a List

2. From Arrays

	- You can create a stream from an array using Arrays.stream().
Example:
--------
	int[] array = {1, 2, 3, 4, 5};
	IntStream stream = Arrays.stream(array);  // Primitive IntStream

	
	- For reference types, you can create a generic stream:
Example:
--------
	String[] array = {"a", "b", "c"};
	Stream<String> stream = Arrays.stream(array);  // Stream of Strings

3. From Individual Values (Stream.of)

	- You can create a stream from a sequence of elements using Stream.of().
Example:
--------
	Stream<String> stream = Stream.of("apple", "banana", "cherry");  // Create a stream from individual elements

4. From File (I/O Streams)

	- Java Streams can also be used for file processing. You can create a stream from a file using Files.lines(), which creates a stream of lines from a file.
Example:
--------
	try {
    		Stream<String> lines = Files.lines(Paths.get("file.txt"));
    		// process the lines
	} catch (IOException e) {
		e.printStackTrace();
	}

5. From Stream Builder (Stream.builder)

	- You can build a stream using a Stream.Builder. This allows you to build a stream in a more controlled way.
Example:
--------
	Stream<Integer> stream = Stream.<Integer>builder()
                               .add(1)
                               .add(2)
                               .add(3)
                               .build();  // Manually building a stream

6. From Random Number Generators (Streams of Primitives)

	- You can generate streams of random numbers using methods from the Random class or Stream class, such as IntStream, LongStream, or DoubleStream.
Example:
--------
	Random random = new Random();
	IntStream intStream = random.ints(5);  // Stream of 5 random integers

7. From Generator Functions (Streams with Iterative Data)

	- You can use Stream.generate() or Stream.iterate() to create streams that generate data based on a function.
	
	- Using Stream.generate() (for an infinite stream, for example):
Example:
--------
	Stream<Integer> infiniteStream = Stream.generate(() -> (int) (Math.random() * 100));

	- Using Stream.iterate() (for a finite sequence, like a Fibonacci sequence):
Example:
--------
	Stream<Integer> fibonacci = Stream.iterate(0, n -> n + 1).limit(10);  // Generate first 10 numbers

8. From Optional (Optional.stream)

	- If you have an Optional<T>, you can create a stream that may contain either a single element or be empty.
Example:
--------
	Optional<String> optional = Optional.of("Hello");
	Stream<String> stream = optional.stream();  // Stream containing the value, or empty if absent

9. Parallel Streams
	- You can also create a parallel stream, which splits the data processing across multiple threads. This is a special case of the regular stream, but it processes data in parallel for performance reasons.

Example:
--------
	List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
	Stream<Integer> parallelStream = list.parallelStream();  // Parallel stream



-> Streams can be created from different element sources.
	- Using of() method we can create Stream.
	- Using stream() method also we can create Stream.

Approach 1:
-----------
	Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);

Approach 2:
-----------
	List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");

	Stream<String> stream = list.stream();

-> By using Streams we can perform below operations on the data.
	- Intermediate Operations.
	- Terminal Operation.

Intermediate Operations:
------------------------
	- Intermediate operations methods will not produce any results. They usually accept Functional interface as parameter and always returns new Stream.
Example:
--------
	- filter() and map() methods.


Terminal Operations:
--------------------
	- Terminal operations methods will produce some results.
Example:
--------
	- count(), collect(), distinct(), forEach() etc.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Stream with Filtering:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Stream interface having filter() method.
-> filter() method will take Predicate as input.
-> Predicate is a Functional interface which will take input and returns Boolean value.
-> Predicate interface contains test() method which is abstract method. This method is used to execute Lambdas.

Example 1: Numbers Filter
-------------------------
package com.tushar.beans;

import java.util.stream.Stream;

public class NumbersFilter {
	public static void main(String[] args) {
		Stream<Integer> stream = Stream.of(4, 8, 12, 6, 7, 11, 24);
		//stream.forEach(System.out::println);
		//stream.filter(number -> number >= 6).forEach(System.out::println);
		Stream<Integer> filteredStream = stream.filter(number -> number >= 6);
		filteredStream.forEach(System.out::println);
	}
}

Example 2: Names Filter
-----------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class NamesFilter {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");
        
        //Stream<String> stream = list.stream();
        //stream.filter(name -> name.startsWith("A")).forEach(System.out::println);
        list.stream().filter(name -> name.startsWith("A")).forEach(System.out::println);
	}
}

Example 3: Persons Filter
-------------------------
package com.tushar.beans;

public class Person {
	
	private String name;
	
	private Integer age;
	
	private String job;
	
	public Person() {
		super();
	}

	public Person(String name, Integer age, String job) {
		super();
		this.name = name;
		this.age = age;
		this.job = job;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getAge() {
		return age;
	}

	public void setAge(Integer age) {
		this.age = age;
	}

	public String getJob() {
		return job;
	}

	public void setJob(String job) {
		this.job = job;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + ", job=" + job + "]";
	}
	
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;

public class PersonsFilter {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 28, "Software");
		Person p2 = new Person("Mahesh", 29, "Driver");
		Person p3 = new Person("Ashok", 30, "Teacher");
		Person p4 = new Person("Sunil", 27, "Mechanic");
		Person p5 = new Person("Bharat", 30, "Chef");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		persons.stream().filter(person -> person.getAge() > 21 && person.getAge() < 30 && 	person.getJob().equals("Software")).forEach(System.out::println);
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Use case for filtering data:
------------------------------------------------------------------------------------------------------------------------------------------------------------
public class Mobile {
	public List<Mobiles> getMobiles(MobileFilter mf) {
		List<Mobiles> mobiles = dao.getMobiles();
		Stream<Mobiles> mobilesStream = null;
		
		if(!"".equals(mf.getBrand())) {
			mobilesStream = mobiles.stream().filter(m -> m.getBrand().equals(mf.getBrand()));
		}

		if(!"".equals(mf.getRam())) {
			mobilesStream = mobiles.stream().filter(m -> m.getRam().equals(mf.getRam()));
		}
		return mobilesStream.collect(Collectors.toList());
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Mapping Operations in Streams
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Mapping operations are belongs to Intermediate operation.

-> Mapping operations are those operations that transform the elements of a stream and return a new stream with transformed elements.

Example 1:
----------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.List;

public class NamesMapping {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");
        
        list.stream().map(name -> name.toUpperCase()).forEach(System.out::println);
	}
}

Example 2:
----------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.List;

public class NamesLength {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");
        
        list.stream().map(name -> name.toUpperCase() + " : " + name.length()).forEach(System.out::println);
	}
}

Example 3:
----------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.List;

public class NamesLength {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");
        
        list.stream().map(name -> name.toUpperCase() + " : " + name.length()).forEach(System.out::println);
        
        //Map to Integer
        list.stream().mapToInt(name -> name.length()).forEach(System.out::println);
        
        //Get names which starts with "A" and length of that names.
        list.stream().filter(name -> name.startsWith("A")).map(name -> name.toUpperCase() + " : " + name.length()).forEach(System.out::println);
     
        //Here first data will transform and then it will filter so this is also gives same output but the issue is this will transform all the data then it will filter.
        list.stream().map(name -> name.toUpperCase() + " : " + name.length()).filter(name -> name.startsWith("A")).forEach(System.out::println);
	
	}
}




















