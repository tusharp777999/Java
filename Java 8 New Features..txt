Java 8 New Features.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Lambda Expressions
Functional Interfaces
	- Predicate
	- Supplier	
	- Consumer
	- Function

Interfaces changes (default & static methods)
Stream API
Method References
Constructor References
Date & Time API changes
Optional class
SplitIterator
StringJoiner
Collection Framework changes


------------------------------------------------------------------------------------------------------------------------------------------------------------
Lambda Expressions
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> LISP is the first Programming Language which supported for Lambda Expression.

LISP
C
C++
C#
Scala
Ruby
Python etc...

-> Java started support for Lambda Expression from 1.8 version (Java is late in Lambdas)
-> Java is an Object Oriented Programming Language. Introducing Lambdas in Java it is supporting Functional Programming also.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Object Oriented Programming Vs Functional Programming?
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In Object Oriented Programming Languages Classes & Objects are main entities.
-> If we want to create a Function in OOP's Languages, that Function should be created inside the class.

-> In Functional Programming, Function can exist outside the scope of an object
-> We can assign Function to a Reference Variable.
-> One Function can be passed as a Parameter to another Function.

------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Lambda?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> A Lambda Expression is just an Anonymous Function
	- No Name.
	- No Modifier.
	- No Return Type.
	- And we use "->" this symbol to represent Lambda.
-> Lambda Expressions are used to implement Functional Programming in Java.
-> By using Lambda Expressions we can write more Readable and Concise code.


Normal Method:

	public void m1() {
		System.out.println("Hi");
	}

Equivalent Lambda:

	() -> System.out.println("Hi");

------------------------------------------------------------------------------------------------------------------------------------------------------------
Why to use Lambda Expressions?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> To write Functional Programming in Java.
-> To write more Readable, Maintainable and Concise code.

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to write Lambda Expressions in Java?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Writing Lambdas is very easy if you know how to write methods in Java.
-> Let us take one example to understand how to write Lambda.

Example 1:
----------

Normal Method:

	public void greet() {
		System.out.println("Hi");
	}

Equivalent Lambda:

	() -> System.out.println("Hi");


Example 2:
----------

Normal Method:

	public void add(int a, int b) {
		System.out.println(a+b);
	}

Equivalent Lambda:

	(a, b) -> System.out.println(a+b);


Example 3:
----------

Normal Method:

	public User getUserById(Integer userId) {
		User user = dao.findById(userId);
		return user;
	}

Equivalent Lambda:

	(userId) -> {
		User user = dao.findById(userId);
		return user;
	};

Example 4:
----------

Normal Method:

public class EmailUtils {

	public Boolean sendMail(String sub, String body, String to){
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setSubject(sub);
		msg.setBody(body);
		msg.setTo(to);

		JavaMailSender sender = new JavaMailSender();
		sender.send(msg);
		return true;
	}

}

Equivalent Lambda:

	(sub, body, to) -> {
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setSubject(sub);
		msg.setBody(body);
		msg.setTo(to);

		JavaMailSender sender = new JavaMailSender();
		sender.send(msg);
		return true;
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to call Lambdas?
------------------------------------------------------------------------------------------------------------------------------------------------------------

Normal Method:
	class Demo {
		public void m1() {
			System.out.println("Hi");
		}
	}

	Demo demo = new Demo();
	demo.m1();

Lambda Way:
	
	class Test {
		() -> System.out.println("Hi");
	}	

-> To call the Normal method of a class we can use the object of that class but to call the Lambda there is no such way of object so for that the concept of Functional Interface is there.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Functional Interface:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> The interface which contains only one abstract method then it is called as Functional interface.
	
	public interface Greeting {
		void greet();
	}	

-> Using Functional Interface we can call or invoke Lambda Expression.
-> Functional Interface can contain any number of Default and Static methods.
-> Functional Interface rule is applicable only for Abstract method. It should contain only one Abstract method and it can contain any number of Static and Default methods.
-> To represent our Interface as Functional Interface we will use @FunctionalInterface annotation.
-> Writing @FunctionalInterface annotation is optional. If we write this annotation compiler will check do we have only one abstract method in the interface or not.

Example 1:(Valid Functional Interface)
--------------------------------------

	@FunctionalInterface
	public interface MyInterface {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

For a proof:

	public interface Demo {
		void m1();
	}

> javac Demo.java
> javap Demo

public interface Demo {
	public abstract void m1();// Here "public abstract" keywords are added by default by the compiler to the method.

}

Example 2:(Invalid Functional Interface)
----------------------------------------

	@FunctionalInterface
	public interface MyInterface {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
		public abstract void m2();
	}

//Here we have 2 abstract methods so that's why it is invalid.

Example 3:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		
	}

-> In the above scenario, Child interface doesn't have any abstract methods. Child having access for the Parent class abstract method hence Child is also Functional Interface.

Example 4:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface overriding Parent interface abstract method hence Child is having only one abstract method. So it is valid Functional Interface.

Example 5:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		void m2();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface having 2 abstract methods hence it is not Functional Interface.

Example 6:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	public interface Child extends Parent {
		void m2();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface can contains any number of abstract methods because it is not having @FunctionalInterface annotation.

Example 7:
----------

	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Parent is Functional Interface only.
-> Writing @FunctionalInterface is optional.
-> If we write @FunctionalInterface, java compiler will verify that is valid Functional Interface or not.

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to invoke Lambdas using Functional Interface?
------------------------------------------------------------------------------------------------------------------------------------------------------------

Without using Lambdas:
----------------------

	public interface MyInterface {
		void m1();
	}

	public class MyApp implements MyInterface {
		public void m1() {
			System.out.println("Hello");
		}

		public static void main(String... args) {
			MyInterface mi = new MyApp();
			mi.m1();
		}
	}

With using Lambdas:
-------------------

	public interface MyInterface {
		void m1();
	}

	public class MyApp {
		public static void main(String... args) {
			MyInterface mi = () -> System.out.println("Hello");
			mi.m1();
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 1: With older approach using implementation classes.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class EnglishGreeting implements Greeting {

	@Override
	public void greet() {
		System.out.println("Hello, Good Morning..!!");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class HindiGreeting implements Greeting {

	@Override
	public void greet() {
		System.out.println("Namaskar...");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisher {

	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		Greeting hindiGreeting = new HindiGreeting();
		wish(hindiGreeting);
		
		Greeting englishGreeting = new EnglishGreeting();
		wish(englishGreeting);
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In above approach we are creating separate implementation class for every language. If we want to support 20 languages then we have to create 20 implementation classes. It is not recommended.
-> To avoid this problem we can use Anonymous implementation class.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2: With older approach using Anonymous implementation for interface.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherAnonymous {
	
	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		wish(new Greeting() {
			@Override
			public void greet() {
				System.out.println("Namaskar...");
			}
		});
		
		wish(new Greeting() {
			@Override
			public void greet() {
				System.out.println("Hello, Good Morning..!!");
			}
		});
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 3: With newer approach using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherLambda {

	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		wish(() -> System.out.println("Namaskar..."));
		
		wish(() -> System.out.println("Hello, Good Morning..!!"));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 4: With newer approach using Lambda(Simplified way).
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherSimplified {

	public static void main(String[] args) {
		Greeting hindiGreeting = () -> System.out.println("Namaskar...");
		hindiGreeting.greet();
		
		Greeting englishGreeting = () -> System.out.println("Hello, Good Morning..!!");
		englishGreeting.greet();
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> In java we have several functional interfaces, they are
	- Runnable
	- Callable
	- ActionListener

------------------------------------------------------------------------------------------------------------------------------------------------------------
Working with Runnable interface available in java.lang package.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Runnable interface contains only one abstract method hence it is called as Functional interface.
	- public void run();

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 1: Using implementation class.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo1 implements Runnable {
	@Override
	public void run() {
		for(int i = 1; i <= 10; i++) {
			System.out.println(i);
		}
	}
	
	public static void main(String[] args) {
		Demo1 demo = new Demo1();
		Thread t = new Thread(demo);
		t.start();
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2: Using Anonymous class implementation.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo2 {
	public static void main(String[] args) {
		Thread t = new Thread(new Runnable() {
			@Override
			public void run() {
				for(int i = 1; i <= 10; i++) {
					System.out.println(i);
				}
			}
		});
		t.start();
	}
}

	or

package com.tushar.beans;

public class Demo3 {
	public static void main(String[] args) {
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				for(int i = 1; i <= 10; i++) {
					System.out.println(i);
				}
			}
		};
		Thread t = new Thread(runnable);
		t.start();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 3: Using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo4 {
	public static void main(String[] args) {
		Runnable runnable = () -> {
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
		};
		
		Thread thread = new Thread(runnable);
		thread.start();
	}
}


	or

package com.tushar.beans;

public class Demo5 {
	public static void main(String[] args) {
		Thread thread = new Thread(() -> {
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
		});
		thread.start();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> In java, We are having Callable interface to work with Multi-Threading.
-> Callable interface contains only one abstract method hence it is called as Functional interface.
	- public Object call();
-> call() returns future object.
-> To execute Callable we will use ExecutorService.
-> ExecutorService is a framework which introduced in java 1.5 version to work with Multi-Threading.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable Examples 1: Using Anonymous class.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		Callable callable = new Callable() {
			@Override
			public Object call() throws Exception {
				for(int i = 1; i <= 20; i++) {
					System.out.println(i);
				}
				return null;
			}
		};
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(callable);
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable Examples 2: Using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		Callable callable = () -> {
			for(int i = 0; i <= 10; i++) {
				System.out.println(i);
			}
			return null;
		};
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(callable);
	}
}

	or

package com.tushar.beans;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(() -> {
			for(int i = 0; i <= 10; i++) {
				System.out.println(i);
			}
			return null;
		});
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Comparator is a predefined interface available in java which is used to implement for Customized sorting.
-> It is present in java.util.Comparator interface contains compare() method.
	- public Interger compare(Object o1, Object o2);

-> We can work with Comparator interface in below 3 ways.
	- Create class to implement Comparator interface and override compare() method.
	- Provide Anonymous implementation for Comparator interface.
	- Provide implementation for Comparator using Lambda Expression.

-> In order to perform Customized sorting we will use Collections.sort() method like below.
	- Collections.sort(listOfObjectsToSort, Comparator<T>);

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 1: Using Normal Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class SortingDemo1 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, new ElementsSortingComparator());
		System.out.println("Elements After Sorting :: " + al);
	}

}

class ElementsSortingComparator implements Comparator<Integer> {
	@Override
	public int compare(Integer o1, Integer o2) {
//		if(o1 > o2) {
//			return -1;
//		} else if(o1 < o2) {
//			return 1;
//		} else {
//			return 0;
//		}
		
		return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 2: Using Anonymous class Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class SortingDemo2 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
			}
		});
		System.out.println("Elements After Sorting :: " + al);
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 3: Using Lambda Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;

public class SortingDemo2 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, (Integer o1, Integer o2) -> {
				return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
			});
		System.out.println("Elements After Sorting :: " + al);
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 1: Using Normal Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class Person {
	private Integer personId;
	private String personName;
	private String personEmail;
	
	public Person() {
		super();
	}

	public Person(Integer personId, String personName, String personEmail) {
		super();
		this.personId = personId;
		this.personName = personName;
		this.personEmail = personEmail;
	}

	public Integer getPersonId() {
		return personId;
	}

	public void setPersonId(Integer personId) {
		this.personId = personId;
	}

	public String getPersonName() {
		return personName;
	}

	public void setPersonName(String personName) {
		this.personName = personName;
	}

	public String getPersonEmail() {
		return personEmail;
	}

	public void setPersonEmail(String personEmail) {
		this.personEmail = personEmail;
	}

	@Override
	public String toString() {
		return "Person [personId=" + personId + ", personName=" + personName + ", personEmail=" + personEmail + "]";
	}
	
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ObjectSorting1 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, new PersonComparator());
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

class PersonComparator implements Comparator<Person> {
	@Override
	public int compare(Person o1, Person o2) {
		return o1.getPersonName().compareTo(o2.getPersonName());
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 2: Using Anonymous class Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ObjectSorting2 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, new Comparator<Person>() {
			@Override
			public int compare(Person o1, Person o2) {
				return o1.getPersonName().compareTo(o2.getPersonName());
			}
		});
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 3: Using Lambda Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ObjectSorting3 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, (o1, o2) -> {
			return o1.getPersonName().compareTo(o2.getPersonName());
		});
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment: Write a java program to sort below Map based on values available in the Map using Lambda Expression.
------------------------------------------------------------------------------------------------------------------------------------------------------------
1   USA
91  India
61  Australia
86  China
33  France
92  Pakistan
852 Hong Kong

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predefined Functional interfaces introduced in java 8.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate
-> Supplier
-> Consumer
-> Function

-> The above Functional interface are provided in java.util.function package.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predicate:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate is pre-defined Functional interface.
-> Predicate is having an abstract method called test() which is used to invoke Lambda Expression.
-> Predicate contains and(), or() & negate() methods which are default methods.
-> Predicate contains isEqual() & not() method which is static method.
-> Predicate is used to perform some conditional check and returns true or false.
-> Predicate is present in java.util.function package.
-> If we have a Lambda which checks condition and returns true or false then we can invoke that Lambda using Predicate Functional interface.

Example:
	- Check whether given number is greater than 20 or not.
	
	//Logic without Lambda
	public boolean test(int number) {
		if(number > 20) {
			return true;
		} else {
			return false;
		}
	}
------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Logic with Lambda
	(number) -> number > 20;
------------------------------------------------------------------------------------------------------------------------------------------------------------
	//With Predicate
	package com.tushar.beans;

	import java.util.function.Predicate;

	public class NumberCheck {
		public static void main(String[] args) {
			Predicate<Integer> predicate = (number) -> number > 20;
			System.out.println(predicate.test(21));
			System.out.println(predicate.test(15));
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to check person name is having 7 characters or not. If name is having 7 or more characters return true otherwise return false.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.function.Predicate;

public class NameLengthCheck {
	public static void main(String[] args) {
		Predicate<String> predicate = name -> name.length() >=7; 
		System.out.println(predicate.test("Tushar Patil"));// true
		System.out.println(predicate.test("Hello"));// false
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to print names which are starting with character 'A' using lambda from below list.
Names: Kajal, Samantha, Anushka, Trisha, Anupama, Nayanthara, Aishwarya.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.function.Predicate;

public class NamesPrinting {
	public static void main(String[] args) {
		String[] names = {"Kajal", "Samantha", "Anushka", "Trisha", "Anupama", "Nayanthara", "Aishwarya"};
		Predicate<String> predicate = name -> name.startsWith("A");
		
		for(String name : names) {
			if(predicate.test(name)) {
				System.out.println(name);
			}
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment:
-----------

Requirement: Write a program to print persons names who are eligible for vote from below person list.

Person Details:
---------------
Name = Raju, Age = 20
Name = Nick, Age = 10
Name = Rani, Age = 21
Name = Sita, Age = 19
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PersonNamesPrinter {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 16);
		Person p4 = new Person("Gita", 24);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> predicate = person -> person.getAge() >= 18;
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person.getName());
			}
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predicate Joining:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> To combine multiple predicates we will use Predicate Joining.
-> We can do method chaining also.
-> We have below methods in Predicate.
	- test() 
		-> It is abstract method.
		-> It takes only one parameter and returns Boolean value.
	- negate() 
		-> It is default method.
		-> It does not take any parameter it just reversed the given predicate.
	- and() 
		-> It is default method.
		-> It combines the predicate and all predicate are true then it return true.
		-> We can do method chaining.
			- Like predicate1.and(predicate2).and(predicateN).
	- or() 
		-> It is default method.
		-> It combines the predicate and any of the predicate is true then returns true.
		-> We can do method chaining.
			- Like predicate1.or(predicate2).or(predicateN).
	- isEqual() 
		-> It is static method. //Not covered in this class
	- not() 
		-> It is static method and now it is deprecated.//Not covered in this class

-> and(), or() & negate() are default methods in Predicate interface.
-> isEqual() & not() are the static methods in Predicate interface.
-> Using and() & or() methods we can achieve predicate joining.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to identify who is eligible for marriage.
Condition: Person age should be >= 21 and <= 64.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 1: and()
----------------

public class PredicateJoinForAnd {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 67);
		Person p4 = new Person("Gita", 14);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> ageLowerUpperLimit = person -> person.getAge() >= 21 && person.getAge() <= 64;
		
		// Here it we are using the conditional operator within single Predicate.
		System.out.println("Predicate with single condition:");
				
		for(Person person : persons) {
			if(ageLowerUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		
		Predicate<Person> ageLowerLimit = person -> person.getAge() >= 21;
		
		Predicate<Person> ageUpperLimit = person -> person.getAge() <= 64;
		
		// Here it we are using the conditional operator which shows a lengthy approach.
		System.out.println("Predicate without joining methods:");
		
		for(Person person : persons) {
			if(ageLowerLimit.test(person) && ageUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		// Here we are using the Predicate joining.
		Predicate<Person> predicate = ageLowerLimit.and(ageUpperLimit);
		System.out.println("Predicate with joining mehtods:");
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person);
			}
		}		
	}
}

Example 2: or()
---------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateJoinForOr {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 67);
		Person p4 = new Person("Gita", 14);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> ageLowerUpperLimit = person -> person.getAge() >= 21 || person.getAge() <= 64;
		
		// Here it we are using the conditional operator within single Predicate.
		System.out.println("Predicate with single condition:");
				
		for(Person person : persons) {
			if(ageLowerUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		
		Predicate<Person> ageLowerLimit = person -> person.getAge() >= 21;
		
		Predicate<Person> ageUpperLimit = person -> person.getAge() <= 64;
		
		// Here it we are using the conditional operator which shows a lengthy approach.
		System.out.println("Predicate without joining methods:");
		
		for(Person person : persons) {
			if(ageLowerLimit.test(person) || ageUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		// Here we are using the Predicate joining.
		Predicate<Person> predicate = ageLowerLimit.or(ageUpperLimit);
		System.out.println("Predicate with joining mehtods:");
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person);
			}
		}		
	}
}

Example 3: negate()
-------------------

package com.tushar.beans;

import java.util.function.Predicate;

public class PredicateEvenCheck {
	public static void main(String[] args) {
		Predicate<Integer> predicate = i -> i % 2 == 0;
		isEvenCheck(predicate, 10);
		isEvenCheckNegate(predicate, 10);
	}
	
	public static void isEvenCheck(Predicate<Integer> predicate, Integer number) {
		System.out.print("Predicate without negate(): ");
		System.out.println(predicate.test(number));
	}
	
	public static void isEvenCheckNegate(Predicate<Integer> predicate, Integer number) {
		System.out.print("Predicate with negate(): ");
		System.out.println(predicate.negate().test(number));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiPredicate:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate<T> takes only one parameter and returns result.
-> If we want to provide 2 parameters as an input for Lambda and return the result then we can use BiPredicate for this.
-> BiPredicate<T, T> is Functional interface which contains a abstract method test().
-> BiPredicate<T, T> takes 2 parameters and returns Boolean value.
-> BiPredicate contains only default methods.
-> Default methods:
	- and()
	- or()
	- negate()
-> BiPredicate does not contains any static method as Predicate have.

Example 1: BiPredicate

package com.tushar.beans;

import java.util.function.BiPredicate;

public class Demo1 {
	public static void main(String[] args) {
		BiPredicate<Integer, Integer> biPredicate = (number1, number2) -> ((number1 + number2) >= 100);
		System.out.println(biPredicate.test(10, 200));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Supplier:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> It is pre-defined Functional interface.
-> It contains only one abstract method i.e. get();
-> It does not contain any default and static methods.
-> Supplier is an interface that does not take any arguments but it produces a value when the get() function got called.
-> Supplier are useful when our Lambda is not taking any input but it is providing some output.
-> There is no BiSupplier because the Supplier don't take any input so no chance of BiSupplier.

Example 1: Get Date
-------------------

package com.tushar.beans;

import java.util.Date;
import java.util.function.Supplier;

public class DateApp {
	public static void main(String[] args) {
		Supplier<Date> dateSupplier = () -> new Date();
		System.out.println(dateSupplier.get());
	}
}

Example 2: Get OTP
------------------

package com.tushar.beans;

import java.util.function.Supplier;

public class OtpGenerator {
	public static void main(String[] args) {
		Supplier<String> otpSupplier = () -> {
			String otp = "";
			for(int i = 1; i <= 6; i++) {
				otp = otp + (int)(Math.random() * 10);
			}
			return otp;
		};
		System.out.println(otpSupplier.get());
		System.out.println(otpSupplier.get());
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Consumer:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> It is pre-defined Functional interface.
-> It contains only one abstract method i.e. accept(T t).
-> It contains only one default method andThen().//Not covered in the class
-> There is no static method in it.
-> Consumer will take only one input but it will not return anything.
-> Consumer can be used in a scenario where our Lambda should take input and perform operation based on the input but no need to return anything.
	- Syntax:
		interface Consumer {
			void accept(T t);
		}

Example 1: Print String and Integer
-----------------------------------

package com.tushar.beans;

import java.util.function.Consumer;

public class ConsumerDemo {
	public static void main(String[] args) {
		Consumer<String> consumer1 = (name) -> System.out.println("Good Morning!!!");
		consumer1.accept("Tushar Patil");
		
		Consumer<Integer> consumer2 = i -> System.out.println(i * i);
		consumer2.accept(10);
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiConsumer:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> If we want to supply 2 inputs for a Lambda and no return then we can use BiConsumer.
	- Syntax:
		interface BiConsumer<T, U> {
			void accept(T t, U u);
		}
		
		T - Represents first argument.
		U - Represents second argument.
-> It contains only one default method andThen().//Not covered in the class
-> There is no static method in it.
Note: BiConsumer interface having only one abstract method i.e. accept(T t, U u). It will take 2 inputs and performs operation but it will not return 
anything.

Example 1: Print Strings
------------------------

package com.tushar.beans;

import java.util.function.BiConsumer;

public class BiConsumerDemo {
	public static void main(String[] args) {
		BiConsumer<String, String> biConsumer = (string1, string2) -> {
			System.out.println("Hi, I am " + string1);
			System.out.println("I am from " + string2);
		};
		
		biConsumer.accept("Tushar", "Pune");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Function:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Function is pre-defined Functional interface.
-> Function is having an abstract method called apply() which is used to invoke Lambda Expression.
-> apply() method takes 1 input and returns output.
-> Function contains compose() & andThen() methods which are default methods.
-> Function contains identity() method which is static method.
-> Function is used to take input and provide output.
-> Function is present in java.util.function package.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a Lambda for below method and call using pre-defined Functional interface.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 1:
----------

public Ticket bookTicket(Passenger passenger) {
	//Logic to book ticket
	return ticketObject;
}

-> As we can see, above bookTicket() method taking passenger object as input and returning Ticket object as output.
-> To work with this kind of requirements we can use Function interface.
-> Function is a pre-defined Functional interface 
-> Function interface can take input and provide output.
-> Function interface contains only one abstract method i.e. R apply(T t)
	- Syntax:
		interface Function {
			R apply(T t);
		}
		
		T - Represents input/parameter object type.
		R - Represents returning object type.

Note: In realtime most of our requirements will match with Function interface only.

Example 2:
----------

Taking LoginForm object as input and returning String as output.

public String login(LoginForm input) {
	//Check login credentials with DB.
	return status;
}

Example 3:
----------

Taking UserForm object input and returning String as output.

public String registerUser(UserForm input) {
	//Insert user in DB.
	return status;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.function.Function;

public class FunctionDemo1 {
	public static void main(String[] args) {
		Function<String, String> function1 = string -> string.toUpperCase();
		System.out.println(function1.apply("Tushar"));
		
		Function<Integer, Integer> function2 = number -> number * number;
		System.out.println(function2.apply(10));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiFunction:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> BiFunction is pre-defined Functional interface.
-> BiFunction is having an abstract method called apply() which is used to invoke Lambda Expression.
-> apply() method takes 2 inputs and returns output.
-> BiFunction contains andThen() method which is default method.
-> BiFunction does not contain any static method.
-> BiFunction is used to take input and provide output.
-> BiFunction is present in java.util.function package.

	- Syntax:
		interface BiFunction<T, U, R> {
			R apply(T t, U u);
		}

		T - First argument type.
		U - Second argument type.
		R - Third argument type.

Example 1:
----------

package com.tushar.beans;

import java.util.function.BiFunction;

public class BiFunctionDemo1 {
	public static void main(String[] args) {
		BiFunction<Integer, Integer, Integer> biFunction1 = (number1, number2) -> (number1 * number2);
		System.out.println(biFunction1.apply(10, 20));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Summary:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate interface will take one input and returns Boolean value as an output.
	- test(argument 1) 
		-> abstract method.
	- and() 
		-> default method.
	- or() 
		-> default method.
	- negate() 
		-> default method.
	- isEqual()
		-> static method.
	- not()
		-> static method.

-> BiPredicate interface will take 2 inputs and returns Boolean value as an output.
	- test(argument 1, argument 2) 
		-> abstract method.
	- and() 
		-> default method.
	- or() 
		-> default method.
	- negate() 
		-> default method.
Note: Don't have any static method as Predicate have.

-> Supplier interface will not take any input and returns output.
	- get() 
		-> abstract method.
Note 1: Supplier don't have default and static methods.
Note 2: Supplier don't have BiSupplier because it doesn't take any input. 

-> Consumer interface will take one input and it won't return anything.
	- accept(argument 1)
		-> abstract method.
	- andThen() 
		-> default method.
Note: Don't have any static method.

-> BiConsumer interface will take 2 inputs and it won't return anything.
	- accept(argument 1, argument 2)
		-> abstract method.
	- andThen() 
		-> default method.
Note: Don't have any static method.

-> Function interface will take one input and returns output.
	- returnType apply(argument 1)
		-> abstract method.
	- andThen() 
		-> default method.
	- compose() 
		-> default method.
	- identity()
		-> static method.

-> BiFunction interface will take 2 inputs and returns output.
	- returnType apply(argument 1, argument 2)
		-> abstract method.
	- andThen() 
		-> default method.
Note: Don't have any static method.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Interface related changes in Java 8:
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> What is interface?
	- Interface is a contract which contains specification.
	- Interface should contain only abstract methods. (This is true upto Java 1.7v)
	- The method which does not having body is called as abstract method.
		-> Example: 
			public User getUserById(Integer userId);
	- From Java 1.8v onwards we can write concrete methods also in interface.
	- The method which contains body is called as Concrete method.
	- Example:
		public Integer sum(Integer number1, Integer number2) {
			return a + b;
		}
Note: Interface concrete methods should be "default", "static" or "private(Java 9)".

-> abstract methods available in the interface are by default public and abstract. No need to write public and abstract keyword explicitly.
	- Example: public abstract void cleanVehicle(); => void cleanVehicle();

Example 1:
----------

package com.tushar.beans;

public interface Vehicle {
	void cleanVehicle();//By default it having public abstract keyword. It is abstract method.

	default void startVehicle() {// Default method with default keyword which is concrete method and valid in interface.
		System.out.println("Vehicle started!!!");
	}
}

-> As per Java rule, when we are implementing interface, we have to implement all the abstract methods available in the interface.
-> If we want to add any new abstract method in interface then the implemented classes will be affected. (Both Santro and I20Car).
-> To avoid this problem default method got introduced in Java 1.8v.
-> If we want to add new functionality in Vehicle interface that should be applicable for only I20Car not for Santro. Without affecting the existing functionality then we should go for "default" method concept. And if we want to allow the overriding the go for default method. Need to call using implementation class object.
-> If there is some logic which is common across the implementation class without affecting the existing functionality and don't want to allow overriding the we should go for static method. Need to call using Interface name.

Example:
--------

package com.tushar.beans;

public interface Vehicle {
	void cleanVehicle();//By default it having public abstract keyword. It is abstract method.
	
	default void sensor() {
		System.out.println("Sensor added!!!");
	}
	
	default void startVehicle() {// Default method with default keyword which is concrete method and valid in interface.
		System.out.println("Vehicle started!!!");
	}
	
	static void fuelCheck() {
		System.out.println("Checking fuel!!!");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class I20Car implements Vehicle {
	@Override
	public void cleanVehicle() {
		System.out.println("I20 car is getting cleaned.");
	}
	
	@Override
	public void sensor() {
		System.out.println("Sensor overrided in I20 class!!!");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class Santro implements Vehicle {
	@Override
	public void cleanVehicle() {
		System.out.println("Santro car is getting cleaned.");
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class MyApp {
	public static void main(String[] args) {
		Vehicle santroVehicle = new Santro();
		santroVehicle.cleanVehicle();
		santroVehicle.startVehicle();
		
		Vehicle i20Vehicle = new I20Car();
		i20Vehicle.cleanVehicle();//It is abstract method which is implemented in the implementation classes and and called using implementation 					    class object.
		i20Vehicle.startVehicle();//Default method call which is not overridden in I20Car and called using implementation class object.
		i20Vehicle.sensor();//Default method call which is overridden in I20Car class and called using implementation class object.
		Vehicle.fuelCheck();//Static method call
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

Static Method:
--------------
-> We can add static method in interface.
-> This concept introduced in Java 1.8v.
-> For static method static keyword is mandatory.
-> The reason to introduced this concept is that existing functionality (implemented classes) should not get disturbed and also should not implement forcefully to override this newly added method.
-> To call this static method we need interface name.
-> If our need is that a concrete method which cannot be able to override in the implementation classes then go for static method concept.


Default Method:
---------------
-> We can add default method in interface.
-> This concept introduced in Java 1.8v.
-> For default method "default" keyword is mandatory.
-> The reason to introduced this concept is that existing functionality (implemented classes) should not get disturbed and also should not implement forcefully to override this newly added method.
-> To call this default method we need implemented class object.
-> If our need is that a concrete method which can be override in the implementation classes then go for default method concept

Private Method://Not covered in the class.
---------------



------------------------------------------------------------------------------------------------------------------------------------------------------------
Method Reference:
------------------------------------------------------------------------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------------------------------------------------------------------------
Constructor Reference:
------------------------------------------------------------------------------------------------------------------------------------------------------------










------------------------------------------------------------------------------------------------------------------------------------------------------------
Mapping Operations in Streams
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Mapping operations are belongs to Intermediate operation.

-> Mapping operations are those operations that transform the elements of a stream and return a new stream with transformed elements.

Example:

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class StreamMapping {
    public static void main(String[] args) {
        
        List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");

        Stream<String> stream = list.stream();

        stream.map(name -> name.toUpperCase()).forEach(System.out::println);
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In last session we discusses about below concepts

I) What is Stream API?
II) What are the advantages of using Stream API
iii) Characteristics of Stream API
iv) What type of operations we can perform using Stream API
	- Intermediate Operations
	- Terminal Operations
v) Stream Creation
	I) of() method
	II) stream() method

vi) Filter operation using Streams -- filter(Predicate p)
vii ) Mapping operation using Streams -- map(Function f)


