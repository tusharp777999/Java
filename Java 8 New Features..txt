Java 8 New Features.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Lambda Expressions
Functional Interfaces
	- Predicate
	- Supplier	
	- Consumer
	- Function

Interfaces changes (default & static methods)
Stream API
Method References
Constructor References
Date & Time API changes
Optional class
SplitIterator
StringJoiner
Collection Framework changes


------------------------------------------------------------------------------------------------------------------------------------------------------------
Lambda Expressions
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> LISP is the first Programming Language which supported for Lambda Expression.

LISP
C
C++
C#
Scala
Ruby
Python etc...

-> Java started support for Lambda Expression from 1.8 version (Java is late in Lambdas)
-> Java is an Object Oriented Programming Language. Introducing Lambdas in Java it is supporting Functional Programming also.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Object Oriented Programming Vs Functional Programming?
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In Object Oriented Programming Languages Classes & Objects are main entities.
-> If we want to create a Function in OOP's Languages, that Function should be created inside the class.

-> In Functional Programming, Function can exist outside the scope of an object
-> We can assign Function to a Reference Variable.
-> One Function can be passed as a Parameter to another Function.

------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Lambda?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> A Lambda Expression is just an Anonymous Function
	- No Name.
	- No Modifier.
	- No Return Type.
	- And we use "->" this symbol to represent Lambda.
-> Lambda Expressions are used to implement Functional Programming in Java.
-> By using Lambda Expressions we can write more Readable and Concise code.


Normal Method:

	public void m1() {
		System.out.println("Hi");
	}

Equivalent Lambda:

	() -> System.out.println("Hi");

------------------------------------------------------------------------------------------------------------------------------------------------------------
Why to use Lambda Expressions?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> To write Functional Programming in Java.
-> To write more Readable, Maintainable and Concise code.

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to write Lambda Expressions in Java?
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Writing Lambdas is very easy if you know how to write methods in Java.
-> Let us take one example to understand how to write Lambda.

Example 1:
----------

Normal Method:

	public void greet() {
		System.out.println("Hi");
	}

Equivalent Lambda:

	() -> System.out.println("Hi");


Example 2:
----------

Normal Method:

	public void add(int a, int b) {
		System.out.println(a+b);
	}

Equivalent Lambda:

	(a, b) -> System.out.println(a+b);


Example 3:
----------

Normal Method:

	public User getUserById(Integer userId) {
		User user = dao.findById(userId);
		return user;
	}

Equivalent Lambda:

	(userId) -> {
		User user = dao.findById(userId);
		return user;
	};

Example 4:
----------

Normal Method:

public class EmailUtils {

	public Boolean sendMail(String sub, String body, String to){
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setSubject(sub);
		msg.setBody(body);
		msg.setTo(to);

		JavaMailSender sender = new JavaMailSender();
		sender.send(msg);
		return true;
	}

}

Equivalent Lambda:

	(sub, body, to) -> {
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setSubject(sub);
		msg.setBody(body);
		msg.setTo(to);

		JavaMailSender sender = new JavaMailSender();
		sender.send(msg);
		return true;
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to call Lambdas?
------------------------------------------------------------------------------------------------------------------------------------------------------------

Normal Method:
	class Demo {
		public void m1() {
			System.out.println("Hi");
		}
	}

	Demo demo = new Demo();
	demo.m1();

Lambda Way:
	
	class Test {
		() -> System.out.println("Hi");
	}	

-> To call the Normal method of a class we can use the object of that class but to call the Lambda there is no such way of object so for that the concept of Functional Interface is there.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Functional Interface:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> The interface which contains only one abstract method then it is called as Functional interface.
	
	public interface Greeting {
		void greet();
	}	

-> Using Functional Interface we can call or invoke Lambda Expression.
-> Functional Interface can contain any number of Default and Static methods.
-> Functional Interface rule is applicable only for Abstract method. It should contain only one Abstract method and it can contain any number of Static and Default methods.
-> To represent our Interface as Functional Interface we will use @FunctionalInterface annotation.
-> Writing @FunctionalInterface annotation is optional. If we write this annotation compiler will check do we have only one abstract method in the interface or not.

Example 1:(Valid Functional Interface)
--------------------------------------

	@FunctionalInterface
	public interface MyInterface {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

For a proof:

	public interface Demo {
		void m1();
	}

> javac Demo.java
> javap Demo

public interface Demo {
	public abstract void m1();// Here "public abstract" keywords are added by default by the compiler to the method.

}

Example 2:(Invalid Functional Interface)
----------------------------------------

	@FunctionalInterface
	public interface MyInterface {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
		public abstract void m2();
	}

//Here we have 2 abstract methods so that's why it is invalid.

Example 3:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		
	}

-> In the above scenario, Child interface doesn't have any abstract methods. Child having access for the Parent class abstract method hence Child is also Functional Interface.

Example 4:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface overriding Parent interface abstract method hence Child is having only one abstract method. So it is valid Functional Interface.

Example 5:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	@FunctionalInterface
	public interface Child extends Parent {
		void m2();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface having 2 abstract methods hence it is not Functional Interface.

Example 6:
----------

	@FunctionalInterface
	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

	public interface Child extends Parent {
		void m2();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Child interface can contains any number of abstract methods because it is not having @FunctionalInterface annotation.

Example 7:
----------

	public interface Parent {
		void m1();// Here "public abstract" keywords are added by default by the compiler to the method.
	}

-> In the above scenario, Parent is Functional Interface only.
-> Writing @FunctionalInterface is optional.
-> If we write @FunctionalInterface, java compiler will verify that is valid Functional Interface or not.

------------------------------------------------------------------------------------------------------------------------------------------------------------
How to invoke Lambdas using Functional Interface?
------------------------------------------------------------------------------------------------------------------------------------------------------------

Without using Lambdas:
----------------------

	public interface MyInterface {
		void m1();
	}

	public class MyApp implements MyInterface {
		public void m1() {
			System.out.println("Hello");
		}

		public static void main(String... args) {
			MyInterface mi = new MyApp();
			mi.m1();
		}
	}

With using Lambdas:
-------------------

	public interface MyInterface {
		void m1();
	}

	public class MyApp {
		public static void main(String... args) {
			MyInterface mi = () -> System.out.println("Hello");
			mi.m1();
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 1: With older approach using implementation classes.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class EnglishGreeting implements Greeting {

	@Override
	public void greet() {
		System.out.println("Hello, Good Morning..!!");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class HindiGreeting implements Greeting {

	@Override
	public void greet() {
		System.out.println("Namaskar...");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisher {

	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		Greeting hindiGreeting = new HindiGreeting();
		wish(hindiGreeting);
		
		Greeting englishGreeting = new EnglishGreeting();
		wish(englishGreeting);
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In above approach we are creating separate implementation class for every language. If we want to support 20 languages then we have to create 20 implementation classes. It is not recommended.
-> To avoid this problem we can use Anonymous implementation class.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2: With older approach using Anonymous implementation for interface.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherAnonymous {
	
	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		wish(new Greeting() {
			@Override
			public void greet() {
				System.out.println("Namaskar...");
			}
		});
		
		wish(new Greeting() {
			@Override
			public void greet() {
				System.out.println("Hello, Good Morning..!!");
			}
		});
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 3: With newer approach using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherLambda {

	public static void wish(Greeting greeting) {
		greeting.greet();
	}
	
	public static void main(String[] args) {
		wish(() -> System.out.println("Namaskar..."));
		
		wish(() -> System.out.println("Hello, Good Morning..!!"));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 4: With newer approach using Lambda(Simplified way).
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public interface Greeting {
	void greet();
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class WellWisherSimplified {

	public static void main(String[] args) {
		Greeting hindiGreeting = () -> System.out.println("Namaskar...");
		hindiGreeting.greet();
		
		Greeting englishGreeting = () -> System.out.println("Hello, Good Morning..!!");
		englishGreeting.greet();
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> In java we have several functional interfaces, they are
	- Runnable
	- Callable
	- ActionListener

------------------------------------------------------------------------------------------------------------------------------------------------------------
Working with Runnable interface available in java.lang package.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Runnable interface contains only one abstract method hence it is called as Functional interface.
	- public void run();

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 1: Using implementation class.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo1 implements Runnable {
	@Override
	public void run() {
		for(int i = 1; i <= 10; i++) {
			System.out.println(i);
		}
	}
	
	public static void main(String[] args) {
		Demo1 demo = new Demo1();
		Thread t = new Thread(demo);
		t.start();
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2: Using Anonymous class implementation.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo2 {
	public static void main(String[] args) {
		Thread t = new Thread(new Runnable() {
			@Override
			public void run() {
				for(int i = 1; i <= 10; i++) {
					System.out.println(i);
				}
			}
		});
		t.start();
	}
}

	or

package com.tushar.beans;

public class Demo3 {
	public static void main(String[] args) {
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				for(int i = 1; i <= 10; i++) {
					System.out.println(i);
				}
			}
		};
		Thread t = new Thread(runnable);
		t.start();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 3: Using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

public class Demo4 {
	public static void main(String[] args) {
		Runnable runnable = () -> {
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
		};
		
		Thread thread = new Thread(runnable);
		thread.start();
	}
}


	or

package com.tushar.beans;

public class Demo5 {
	public static void main(String[] args) {
		Thread thread = new Thread(() -> {
			for(int i = 1; i <= 10; i++) {
				System.out.println(i);
			}
		});
		thread.start();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> In java, We are having Callable interface to work with Multi-Threading.
-> Callable interface contains only one abstract method hence it is called as Functional interface.
	- public Object call();
-> call() returns future object.
-> To execute Callable we will use ExecutorService.
-> ExecutorService is a framework which introduced in java 1.5 version to work with Multi-Threading.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable Examples 1: Using Anonymous class.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		Callable callable = new Callable() {
			@Override
			public Object call() throws Exception {
				for(int i = 1; i <= 20; i++) {
					System.out.println(i);
				}
				return null;
			}
		};
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(callable);
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Callable Examples 2: Using Lambda.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		Callable callable = () -> {
			for(int i = 0; i <= 10; i++) {
				System.out.println(i);
			}
			return null;
		};
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(callable);
	}
}

	or

package com.tushar.beans;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CallableDemo1 {
	public static void main(String[] args) {
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.submit(() -> {
			for(int i = 0; i <= 10; i++) {
				System.out.println(i);
			}
			return null;
		});
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Comparator is a predefined interface available in java which is used to implement for Customized sorting.
-> It is present in java.util.Comparator interface contains compare() method.
	- public Interger compare(Object o1, Object o2);

-> We can work with Comparator interface in below 3 ways.
	- Create class to implement Comparator interface and override compare() method.
	- Provide Anonymous implementation for Comparator interface.
	- Provide implementation for Comparator using Lambda Expression.

-> In order to perform Customized sorting we will use Collections.sort() method like below.
	- Collections.sort(listOfObjectsToSort, Comparator<T>);

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 1: Using Normal Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class SortingDemo1 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, new ElementsSortingComparator());
		System.out.println("Elements After Sorting :: " + al);
	}

}

class ElementsSortingComparator implements Comparator<Integer> {
	@Override
	public int compare(Integer o1, Integer o2) {
//		if(o1 > o2) {
//			return -1;
//		} else if(o1 < o2) {
//			return 1;
//		} else {
//			return 0;
//		}
		
		return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 2: Using Anonymous class Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class SortingDemo2 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
			}
		});
		System.out.println("Elements After Sorting :: " + al);
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Comparator Examples 3: Using Lambda Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.ArrayList;
import java.util.Collections;

public class SortingDemo2 {

	public static void main(String[] args) {
		ArrayList<Integer> al = new ArrayList<Integer>();
		al.add(10);
		al.add(21);
		al.add(32);
		al.add(5);
		al.add(8);
		
		System.out.println("Elements Before Sorting :: " + al);
		
		Collections.sort(al, (Integer o1, Integer o2) -> {
				return (o1 > o2) ? -1 : (o1 < o2) ? 1 : 0;
			});
		System.out.println("Elements After Sorting :: " + al);
	}

}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 1: Using Normal Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

public class Person {
	private Integer personId;
	private String personName;
	private String personEmail;
	
	public Person() {
		super();
	}

	public Person(Integer personId, String personName, String personEmail) {
		super();
		this.personId = personId;
		this.personName = personName;
		this.personEmail = personEmail;
	}

	public Integer getPersonId() {
		return personId;
	}

	public void setPersonId(Integer personId) {
		this.personId = personId;
	}

	public String getPersonName() {
		return personName;
	}

	public void setPersonName(String personName) {
		this.personName = personName;
	}

	public String getPersonEmail() {
		return personEmail;
	}

	public void setPersonEmail(String personEmail) {
		this.personEmail = personEmail;
	}

	@Override
	public String toString() {
		return "Person [personId=" + personId + ", personName=" + personName + ", personEmail=" + personEmail + "]";
	}
	
}

------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ObjectSorting1 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, new PersonComparator());
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

class PersonComparator implements Comparator<Person> {
	@Override
	public int compare(Person o1, Person o2) {
		return o1.getPersonName().compareTo(o2.getPersonName());
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 2: Using Anonymous class Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ObjectSorting2 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, new Comparator<Person>() {
			@Override
			public int compare(Person o1, Person o2) {
				return o1.getPersonName().compareTo(o2.getPersonName());
			}
		});
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Sorting Objects Examples 3: Using Lambda Approach.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ObjectSorting3 {
	public static void main(String[] args) {
		Person p1 = new Person(101, "Nick", "nick@ashokit.in");
		Person p2 = new Person(102, "Orlen", "orlen@ashokit.in");
		Person p3 = new Person(103, "John", "john@ashokit.in");
		Person p4 = new Person(104, "Charles", "charles@ashokit.in");
		Person p5 = new Person(105, "Smith", "smith@ashokit.in");
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		System.out.println("=====Objects before sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
		
		Collections.sort(persons, (o1, o2) -> {
			return o1.getPersonName().compareTo(o2.getPersonName());
		});
		System.out.println("=====Objects after sorting=====");
		for(Person p : persons) {
			System.out.println(p);
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment: Write a java program to sort below Map based on values available in the Map using Lambda Expression.
------------------------------------------------------------------------------------------------------------------------------------------------------------
1   USA
91  India
61  Australia
86  China
33  France
92  Pakistan
852 Hong Kong

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predefined Functional interfaces introduced in java 8.
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate
-> Supplier
-> Consumer
-> Function

-> The above Functional interface are provided in java.util.function package.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predicate:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate is pre-defined Functional interface.
-> Predicate is having an abstract method called test() which is used to invoke Lambda Expression.
-> Predicate is used to perform some conditional check and returns true or false.
-> Predicate is present in java.util.function package.
-> If we have a Lambda which checks condition and returns true or false then we can invoke that Lambda using Predicate Functional interface.

Example:
	- Check whether given number is greater than 20 or not.
	
	//Logic without Lambda
	public boolean test(int number) {
		if(number > 20) {
			return true;
		} else {
			return false;
		}
	}
------------------------------------------------------------------------------------------------------------------------------------------------------------
	//Logic with Lambda
	(number) -> number > 20;
------------------------------------------------------------------------------------------------------------------------------------------------------------
	//With Predicate
	package com.tushar.beans;

	import java.util.function.Predicate;

	public class NumberCheck {
		public static void main(String[] args) {
			Predicate<Integer> predicate = (number) -> number > 20;
			System.out.println(predicate.test(21));
			System.out.println(predicate.test(15));
		}
	}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to check person name is having 7 characters or not. If name is having 7 or more characters return true otherwise return false.
------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.tushar.beans;

import java.util.function.Predicate;

public class NameLengthCheck {
	public static void main(String[] args) {
		Predicate<String> predicate = name -> name.length() >=7; 
		System.out.println(predicate.test("Tushar Patil"));// true
		System.out.println(predicate.test("Hello"));// false
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to print names which are starting with character 'A' using lambda from below list.
Names: Kajal, Samantha, Anushka, Trisha, Anupama, Nayanthara, Aishwarya.
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.function.Predicate;

public class NamesPrinting {
	public static void main(String[] args) {
		String[] names = {"Kajal", "Samantha", "Anushka", "Trisha", "Anupama", "Nayanthara", "Aishwarya"};
		Predicate<String> predicate = name -> name.startsWith("A");
		
		for(String name : names) {
			if(predicate.test(name)) {
				System.out.println(name);
			}
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Assignment:
-----------

Requirement: Write a program to print persons names who are eligible for vote from below person list.

Person Details:
---------------
Name = Raju, Age = 20
Name = Nick, Age = 10
Name = Rani, Age = 21
Name = Sita, Age = 19
------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PersonNamesPrinter {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 16);
		Person p4 = new Person("Gita", 24);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> predicate = person -> person.getAge() >= 18;
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person.getName());
			}
		}
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
Predicate Joining:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> To combine multiple predicates we will use Predicate Joining.
-> We can do method chaining also.
-> We have below methods in Predicate.
	- test() 
		-> It is abstract method.
		-> It takes only one parameter and returns Boolean value.
	- negate() 
		-> It is default method.
		-> It does not take any parameter it just reversed the given predicate.
	- and() 
		-> It is default method.
		-> It combines the predicate and all predicate are true then it return true.
		-> We can do method chaining.
			- Like predicate1.and(predicate2).and(predicateN).
	- or() 
		-> It is default method.
		-> It combines the predicate and any of the predicate is true then returns true.
		-> We can do method chaining.
			- Like predicate1.or(predicate2).or(predicateN).
	- isEqual() -> It is static method. //Not took in this course
-> and(), or() and negate() are default methods in Predicate interface.
-> Using and() & or() methods we can achieve predicate joining.

------------------------------------------------------------------------------------------------------------------------------------------------------------
Requirement: Write a program to identify who is eligible for marriage.
Condition: Person age should be >= 21 and <= 64.
------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 1: and()
----------------

public class PredicateJoinForAnd {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 67);
		Person p4 = new Person("Gita", 14);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> ageLowerUpperLimit = person -> person.getAge() >= 21 && person.getAge() <= 64;
		
		// Here it we are using the conditional operator within single Predicate.
		System.out.println("Predicate with single condition:");
				
		for(Person person : persons) {
			if(ageLowerUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		
		Predicate<Person> ageLowerLimit = person -> person.getAge() >= 21;
		
		Predicate<Person> ageUpperLimit = person -> person.getAge() <= 64;
		
		// Here it we are using the conditional operator which shows a lengthy approach.
		System.out.println("Predicate without joining methods:");
		
		for(Person person : persons) {
			if(ageLowerLimit.test(person) && ageUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		// Here we are using the Predicate joining.
		Predicate<Person> predicate = ageLowerLimit.and(ageUpperLimit);
		System.out.println("Predicate with joining mehtods:");
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person);
			}
		}		
	}
}

Example 2: or()
---------------
package com.tushar.beans;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateJoinForOr {
	public static void main(String[] args) {
		Person p1 = new Person("Raju", 21);
		Person p2 = new Person("Chetan", 23);
		Person p3 = new Person("Anil", 67);
		Person p4 = new Person("Gita", 14);
		Person p5 = new Person("Suchitra", 26);
		
		List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5);
		
		Predicate<Person> ageLowerUpperLimit = person -> person.getAge() >= 21 || person.getAge() <= 64;
		
		// Here it we are using the conditional operator within single Predicate.
		System.out.println("Predicate with single condition:");
				
		for(Person person : persons) {
			if(ageLowerUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		
		Predicate<Person> ageLowerLimit = person -> person.getAge() >= 21;
		
		Predicate<Person> ageUpperLimit = person -> person.getAge() <= 64;
		
		// Here it we are using the conditional operator which shows a lengthy approach.
		System.out.println("Predicate without joining methods:");
		
		for(Person person : persons) {
			if(ageLowerLimit.test(person) || ageUpperLimit.test(person)) {
				System.out.println(person);
			}
		}
		
		// Here we are using the Predicate joining.
		Predicate<Person> predicate = ageLowerLimit.or(ageUpperLimit);
		System.out.println("Predicate with joining mehtods:");
		
		for(Person person : persons) {
			if(predicate.test(person)) {
				System.out.println(person);
			}
		}		
	}
}

Example 3: negate()
-------------------

package com.tushar.beans;

import java.util.function.Predicate;

public class PredicateEvenCheck {
	public static void main(String[] args) {
		Predicate<Integer> predicate = i -> i % 2 == 0;
		isEvenCheck(predicate, 10);
		isEvenCheckNegate(predicate, 10);
	}
	
	public static void isEvenCheck(Predicate<Integer> predicate, Integer number) {
		System.out.print("Predicate without negate(): ");
		System.out.println(predicate.test(number));
	}
	
	public static void isEvenCheckNegate(Predicate<Integer> predicate, Integer number) {
		System.out.print("Predicate with negate(): ");
		System.out.println(predicate.negate().test(number));
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
BiPredicate:
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Predicate<T> takes only one parameter and returns result.
-> If we want to provide 2 parameters as an input for Lambda and return the result then we can use BiPredicate for this.
-> BiPredicate<T, T> is Functional interface which contains a abstract method test().
-> BiPredicate<T, T> takes 2 parameters and returns Boolean value.
-> BiPredicate contains only default methods but not any static method as Predicate have.
-> Default methods:
	- and()
	- or()
	- negate()

Example 1: BiPredicate

package com.tushar.beans;

import java.util.function.BiPredicate;

public class Demo1 {
	public static void main(String[] args) {
		BiPredicate<Integer, Integer> biPredicate = (number1, number2) -> ((number1 + number2) >= 100);
		System.out.println(biPredicate.test(10, 200));
	}
}


















------------------------------------------------------------------------------------------------------------------------------------------------------------
Mapping Operations in Streams
------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Mapping operations are belongs to Intermediate operation.

-> Mapping operations are those operations that transform the elements of a stream and return a new stream with transformed elements.

Example:

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class StreamMapping {
    public static void main(String[] args) {
        
        List<String> list = new ArrayList<>();
        list.add("Anushka");
        list.add("Trisha");
        list.add("Nayantara");
        list.add("Pooja Hedge");
        list.add("Anupama Parmeshwaram");
        list.add("Amisha Patel");

        Stream<String> stream = list.stream();

        stream.map(name -> name.toUpperCase()).forEach(System.out::println);
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

-> In last session we discusses about below concepts

I) What is Stream API?
II) What are the advantages of using Stream API
iii) Characteristics of Stream API
iv) What type of operations we can perform using Stream API
	- Intermediate Operations
	- Terminal Operations
v) Stream Creation
	I) of() method
	II) stream() method

vi) Filter operation using Streams -- filter(Predicate p)
vii ) Mapping operation using Streams -- map(Function f)


