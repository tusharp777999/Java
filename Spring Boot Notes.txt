Spring Boot Syllabus (Beginner to Advanced)
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Module 1: Introduction to Spring Boot
-------------------------------------------------------------------------------------------------------------------------------------------------------------

What is Spring Boot?
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Boot is a framework for building applications in the Java Programming Language.

Official:
---------
Spring Boot helps you to create stand-alone, production-grade Spring-based applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.

-> The core Spring framework already reduces boilerpalte code and provides a lot of helpful features for Java application. However, Spring Boot takes this convenience to the next level by focusing specifically on reducing the effort required to set up and configure a Spring application.

-> While Spring does simplify many tasks like.
	-> Creating web application.
	-> Working with databases.
	-> Managing transactions. and more....

-> But setting up a Spring project can still involve quite a bit of manual configuration. This is where Spring Boot steps in. It create a Standalone application and Auto configurable. 

-> You don't need any external Tomcat server to run the Spring Boot application jar file. It contains already embedded Tomcat Server.

-> We use the @SpringBootApplication annotation on the main class. This single annotation replaces the need for setting up a manual Spring application context.

-> We no longer need to explicitly create an application context using AnnotationConfigApplicationContext as Spring Boot handles that behind the scenes.

-> We use SpringApplication.run() to start the application, and Spring Boot takes care of configuring the embedded web server and other necessary components.

-> The @SpringBootApplication annotation alone brings in a lot of pre-configured features, including automatic component scanning and embedded server configuration, which would have required more steps in a traditional Spring setup.

What is Embeded Server?
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Normally we have Hardware and on top of it there is Operating System and to install any Application server we need a software of that Application and then need to install then connect it with Spring or any Application then create the WAR file and deploy on the server then the question arises here What is Embeded Server. The Embeded Server(Tomcat Server) which resides inside the JAR and this file will run on Java which is needed for the Spring boot Application to run the Application.

Official:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Embedded Tomcat in Spring Boot refers to the built-in Apache Tomcat server that runs your Spring Boot application as a standalone Java application without requiring an external servlet container.

Advantages of Embedded Tomcat in Spring Boot:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-> No need to deploy a WAR fileâ€”Run as a JAR (java -jar app.jar).
-> Easier to manage & configure compared to traditional application servers.
-> Works seamlessly with Spring Boot auto-configuration.
-> Can be replaced with Jetty or Undertow if needed.

How Embedded Tomcat Works in Spring Boot:
-------------------------------------------------------------------------------------------------------------------------------------------------------------

Auto-Configuration:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-> Spring Boot automatically configures an embedded Tomcat server when you use spring-boot-starter-web.
The server starts when you run your main() method.

Dependencies:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-> If you include spring-boot-starter-web, Spring Boot automatically adds the necessary dependencies for Tomcat:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
This dependency includes spring-boot-starter-tomcat.

Default Configuration:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Runs on port 8080 by default.
Supports Servlet 3.0+ without requiring web.xml.
Uses an embedded version of Tomcat (no need for manual installation).

Customizing Embedded Tomcat:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
You can customize port, context path, max threads, etc., via application.properties:
server.port=9090
server.servlet.context-path=/myapp
server.tomcat.max-threads=200

Disabling Embedded Tomcat (Switching to Another Server):
-------------------------------------------------------------------------------------------------------------------------------------------------------------
If you want to use Jetty or Undertow instead of Tomcat, you can exclude spring-boot-starter-tomcat and add a different server dependency:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>

Features & Advantages of Spring Boot:
-------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring Boot vs Traditional Spring Framework:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Framework:
-----------------
-> Spring Framework is a widely used Java EE framework for building applications.
-> It aims to simplify Java EE development that makes developers more productive.
-> The primary feature of the Spring Framework is dependency injection.
-> It helps to make things simpler by allowing us to develop loosely coupled applications.

Spring Boot Framework:
----------------------
-> Spring Boot is another approach to develop Spring-based applications with minimal configurations.
-> Spring Boot is mainly used to develop REST APIs.
-> The primary feature of Spring Boot is Auto-configuration. It automatically configures the classes based on the requirement.
-> Spring Boot offers an embedded server such as Jetty and Tomcat, etc.

Main Difference:
---------------
Starter POMs: 
In Spring we need to add all the individual dependencies like if we want to develop web application what all dependencies it needed we need to add it manually in Spring and in Spring boot if we add a starter POM it will take care of it.

Version compatibility: 
In Spring we need to check for our framework which version of other supported dependency is compatible but in Spring Boot we have parent dependency where version is mentioned so whenever we adding the child dependency in it we don't mention the version of it the parent will take care of it which is latest version of that child dependency and which is compatible to the framework version so it will take care of it.

Auto Configuration:
In Spring we need to configure many things like web.xml this work as deployment descriptor where we configure our listeners, context parameters, config parameters front controller and URL pattern for the front controller, root-context.xml in this we will configure business component which we required for our application like transaction manager or data source session factory or hibernate template etc , servlet-context.xml in this we will configure web component which are required for our application like view resolver or resources path or component scanning.

But in Spring Boot above configuration files not required because whatever things required for our application is automatically configured by the Spring Boot only.

Component Scanning: 
Is used to identify which classes need to be considered as a Spring Bean in our application and the life cycle of this Spring beans is managed by the IOC container.

Embedded Server:
To run Spring project we need external server but for Spring Boot we have embedded server.

In Memory DB:
Spring need external Database server like MySQL, Oracle etc, But in Spring Boot external database setup is not required because Spring Boot have very good integration with In Memory Database, So when application starts this database also starts and when application stops this database also stopped. So its like a temporary database for quick things where I don't want to store the data permanent only for testing purpose then this database is very useful. Example H2 Database. Just add the H2 related database dependency. Useful in POC concepts and Unit testing.

Actuators:
It's main purpose is Production ready features, It means when our application is deployed on production server or environment we cannot say our work is completed it is our responsibility to manage and to monitor the application in the production if the application is running on the production is equal to a patient in the ICU where the monitoring is done 24X7 


Setting up a Spring Boot Project (Spring Initializr, Maven, Gradle):
-------------------------------------------------------------------------------------------------------------------------------------------------------------
There are two ways:
-------------------

1. Use STS(Spring Tool Suite):
------------------------------
Steps: File -> New -> Spring Starter Project -> Fill the details

Service URL: https://start.spring.io
Name: demo
Use default location: â˜‘ Checked
Location: /home/tushar/Java/Framework/demo

Type: Gradle - Groovy Packaging: Jar
Java Version: 17 Language: Java

Group: com.example
Artifact: demo
Version: 0.0.1-SNAPSHOT
Description: Demo project for Spring Boot
Package: com.example.demo

Working sets: â˜ Add project to working sets

Actions: [New...] [Select...]

Navigation: [< Back] [Next >] [Cancel] [Finish]


2. Using Spring Boot initializer:
-----------------------------------
-> Goto: https://start.spring.io/ -> Fill up the same details as above for type 1. -> Generate the project. -> Download it.
-> Extract the zip file. -> Import it in your IDE.

Note: Don't add any dependency in it. By default it comes with Spring Boot Starter dependency.
Example:
<groupId>com.tushar</groupId>
<artifactId>Spring-Basics</artifactId>
<version>0.0.1-SNAPSHOT</version>
<name>Spring-Basics</name>
<description>Spring Boot Basics</description>

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-test</artifactId>
	<scope>test</scope>
</dependency>
<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
		</plugin>
	</plugins>
</build>

ğŸ”¸ Understanding pom.xml and dependencies

Module 2: Spring Boot Core Concepts
-------------------------------------------------------------------------------------------------------------------------------------------------------------

ğŸ”¸ Spring Boot Annotations:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-> @SpringBootApplication:
It consist of 3 annotations @SpringBootConfiguration (It uses internally @Configuration) then @EnableAutoConfiguration and @ComponentScan.

@Configuration: In Spring Boot there are XML based configuration, Java based configuration and Annotation based configuration. So here it is used for Java based configuration as below is the example for this.

@Configuration
public class SpringConfig {
	//beans
}

@EnableAutoConfiguration: In Spring Boot whenever it finds the dependency with spring-boot-starter-web in a classpath then this annotation will enable dispatcher servlet auto configuration class view resolver auto configuration class and other related auto configuration classes.

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>


In pom.xml when we add any starter dependency it pulls all the jars related to it and add to our project in that one autoconfiguration jar is present which which META-INF/spring.factories means in META-INF is a folder in which the spring.factories file is present which contains all the autoconfiguration is present 

How to see the auto configuration file:
---------------------------------------
In maven .m2 folder we need to reach to the autoconfigure jar and view it 

ushar@tushar-FRI-FXX:~/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/3.4.3$ jar xf spring-boot-autoconfigure-3.4.3.jar META-INF/spring.factories
tushar@tushar-FRI-FXX:~/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/3.4.3$ cat META-INF/spring.factories
# ApplicationContext Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=\
org.springframework.boot.autoconfigure.integration.IntegrationPropertiesEnvironmentPostProcessor

# Auto Configuration Import Listeners
org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition

# Failure Analyzers
org.springframework.boot.diagnostics.FailureAnalyzer=\
org.springframework.boot.autoconfigure.data.redis.RedisUrlSyntaxFailureAnalyzer,\
org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\
org.springframework.boot.autoconfigure.jooq.NoDslContextBeanFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.MissingR2dbcPoolDependencyFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.MultipleConnectionPoolConfigurationsFailureAnalyzer,\
org.springframework.boot.autoconfigure.r2dbc.NoConnectionFactoryBeanFailureAnalyzer,\
org.springframework.boot.autoconfigure.ssl.BundleContentNotWatchableFailureAnalyzer

# Template Availability Providers
org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\
org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider

# DataSource Initializer Detectors
org.springframework.boot.sql.init.dependency.DatabaseInitializerDetector=\
org.springframework.boot.autoconfigure.flyway.FlywayMigrationInitializerDatabaseInitializerDetector

# Depends on Database Initialization Detectors
org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitializationDetector=\
org.springframework.boot.autoconfigure.batch.JobRepositoryDependsOnDatabaseInitializationDetector,\
org.springframework.boot.autoconfigure.quartz.SchedulerDependsOnDatabaseInitializationDetector,\

What is spring.factories?
-------------------------------------------------------------------------------------------------------------------------------------------------------------
    It is a Spring Boot configuration file that registers auto-configuration classes, ApplicationContextInitializer, ApplicationListener, and more.
    Example content:

org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration

The META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports file always contains all available auto-configuration classes, regardless of whether you have added the relevant dependency or not.

However, Spring Boot will only trigger (activate) the configurations that match the conditions in your application. This is controlled using various @Conditional* annotations

How Spring Boot Auto-Configuration Works

	Spring Boot Loads All Auto-Configuration Classes
        	During startup, Spring Boot scans AutoConfiguration.imports and loads all listed auto-configuration classes into memory.
        	Example:
       		org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
		org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
		org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration

	Spring Boot Checks Conditional Annotations Each auto-configuration class has conditions like:
    		@ConditionalOnClass â†’ Enables the configuration only if the specified class exists.
    		@ConditionalOnMissingBean â†’ Configures only if a specific bean is not already defined.
    		@ConditionalOnProperty â†’ Enables configuration based on a property (e.g., spring.datasource.url).
    		
    	Only Matching Configurations Are Activated
		Example 1: JPA Configuration
        	JpaRepositoriesAutoConfiguration only loads if Spring Data JPA is present:

		@Configuration
		@ConditionalOnClass({ EntityManagerFactory.class, EnableJpaRepositories.class })
		@EnableConfigurationProperties(JpaProperties.class)
		public class JpaRepositoriesAutoConfiguration { ... }

		If you don't add spring-boot-starter-data-jpa, this configuration won't be activated.
		
		Example 2: Web Configuration

    		WebMvcAutoConfiguration only activates if Spring MVC is present:

		@Configuration
		@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
		@EnableConfigurationProperties(WebProperties.class)
		public class WebMvcAutoConfiguration { ... }

		If you don't add spring-boot-starter-web, this configuration wonâ€™t run.
		
	Spring Boot Applies Only the Necessary Auto-Configurations

    		Even though AutoConfiguration.imports lists all available configurations, only those that meet the required conditions (dependencies, class 					availability, properties) are actually executed.

Key Takeaways

AutoConfiguration.imports always lists all auto-configurations, even if the corresponding dependencies are missing.
Only relevant auto-configurations are activated, based on:
Presence of required dependencies
Conditions (@ConditionalOnClass, @ConditionalOnProperty, etc.) 
Unused auto-configurations are ignored and do not affect application performance.
You can check active configurations using:
http://localhost:8080/actuator/conditions

ğŸ”¸ Spring Boot Starter Dependencies
ğŸ”¸ Spring Boot Application Structure

Running a Spring Boot Application:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.veracity.india1.first;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class SpringBasicsApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringBasicsApplication.class, args);
		System.out.println("Hello, Spring boot");
	}

}

Note: Without dependency it comes with Spring Boot Starter.

Spring Banner on and off:
-------------------------------------------------------------------------------------------------------------------------------------------------------------
There are two ways:
Using properties:
-----------------
spring.main.banner-mode=off

Using programming:
------------------
@SpringBootApplication
public class SpringBasicsApplication {

	public static void main(String[] args) {
		//SpringApplication.run(SpringBasicsApplication.class, args);
		new SpringApplicationBuilder(SpringBasicsApplication.class)
		.bannerMode(Banner.Mode.OFF)
		.run(args);
	}

}

If you want your own banner:
-----------------------------
-> Goto https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20
-> Create the banner.
-> Copy the ascii value (You can take text type or image type banner no issue.)
-> Create the banner.txt file.(It is default file name) in src/main/resources.
	Note: If you dont want to use the default name for the file which is banner.txt the you can mention the path in application.properties like
	spring.banner.location=(path of a file.)
-> Paste the banner which is you copied and run the application and see the console.


ğŸ”¸ Spring Boot Configuration (application.properties vs application.yml)

ğŸ”¹ Module 3: Dependency Injection & IoC
ğŸ”¸ Understanding IoC (Inversion of Control)
ğŸ”¸ Spring Boot Annotations (@Component, @Service, @Repository, @Bean)
ğŸ”¸ Constructor Injection vs Field Injection
ğŸ”¸ Profiles & Conditional Beans (@Profile, @Conditional)

ğŸ”¹ Module 4: Spring Boot REST API Development
ğŸ”¸ Creating REST APIs with @RestController
ğŸ”¸ Handling HTTP Requests (@GetMapping, @PostMapping, @PutMapping, @DeleteMapping)
ğŸ”¸ Request & Response Bodies (@RequestBody, @ResponseBody)
ğŸ”¸ Path Variables & Query Parameters (@PathVariable, @RequestParam)
ğŸ”¸ Exception Handling (@ControllerAdvice, @ExceptionHandler)

ğŸ”¹ Module 5: Spring Boot Data Access (JPA & Hibernate)
ğŸ”¸ Introduction to Spring Data JPA
ğŸ”¸ Configuring MySQL / PostgreSQL in Spring Boot
ğŸ”¸ Defining Entity Classes (@Entity, @Table, @Id)
ğŸ”¸ Creating Repositories (JpaRepository, CrudRepository)
ğŸ”¸ Custom Queries using @Query & JPQL
ğŸ”¸ Pagination & Sorting (Pageable, Sort)

ğŸ”¹ Module 6: Spring Boot Security (Authentication & Authorization)
ğŸ”¸ Introduction to Spring Security
ğŸ”¸ Configuring Basic Authentication
ğŸ”¸ Role-Based Access Control (RBAC)
ğŸ”¸ JWT Authentication (JSON Web Tokens)
ğŸ”¸ OAuth2 & Social Login (Google, Facebook)
ğŸ”¸ Implementing CORS & CSRF Protection

ğŸ”¹ Module 7: Spring Boot Microservices
ğŸ”¸ Introduction to Microservices Architecture
ğŸ”¸ Building a Simple Microservice in Spring Boot
ğŸ”¸ Service Communication (REST, Feign Client)
ğŸ”¸ API Gateway with Spring Cloud Gateway
ğŸ”¸ Load Balancing with Spring Cloud LoadBalancer
ğŸ”¸ Service Discovery using Eureka
ğŸ”¸ Circuit Breaker using Resilience4J
ğŸ”¸ Distributed Tracing using Zipkin

ğŸ”¹ Module 8: Spring Boot Messaging (Kafka, RabbitMQ)
ğŸ”¸ Introduction to Event-Driven Architecture
ğŸ”¸ Apache Kafka Integration with Spring Boot
ğŸ”¸ RabbitMQ Integration with Spring Boot
ğŸ”¸ Implementing Producer-Consumer Architecture

ğŸ”¹ Module 9: Spring Boot Testing
ğŸ”¸ Unit Testing with JUnit & Mockito
ğŸ”¸ Testing REST APIs using MockMvc
ğŸ”¸ Integration Testing in Spring Boot
ğŸ”¸ Writing Test Cases for Service & Repository Layers

ğŸ”¹ Module 10: Spring Boot DevOps & Deployment
ğŸ”¸ Containerization with Docker
ğŸ”¸ CI/CD with Jenkins & GitHub Actions
ğŸ”¸ Deploying Spring Boot on AWS, Azure, Google Cloud
ğŸ”¸ Monitoring with Spring Boot Actuator
ğŸ”¸ Logging with Logback & ELK Stack

